[{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/clibasics.html","topic":"cli basics","description":"Basic CLI commands\r \r Basic CLI commands\r \r \r Basic CLI commands\r \r The cli is a powerful helper for your fast-paced reality.\r If you have a setup similar as described in quick-start,\r you should have a working cli execution via php cli.\r The tool is extendable and customizable, so here we are goi...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r\n<!--    url: \/docs\/cli-basics -->\r <h1>CLI Basics<\/h1>\r <p>Basic CLI commands<\/p>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/cli-basics\/#basics\" class=\"button-primary\">Basic CLI commands<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"basics\">Basic CLI commands<\/h2>\r <p>\r The cli is a powerful helper for your fast-paced reality.\r If you have a setup similar as described in <a href=\"\/quick-start#cli\">quick-start<\/a>,\r you should have a working cli execution via <code class=\"language-shell\">php cli<\/code>.\r The tool is extendable and customizable, so here we are going to focus on an introduction of the most useful and common commands:\r <\/p>\r <div class=\"grid grid-cols-3 gap-3\">\r <div class=\"border-b-2 border-primary font-lg span-x-2\">Command<\/div>\r <div class=\"border-b-2 border-primary font-lg\">Description<\/div>\r <p class=\"span-x-2\">list<\/p>\r <p>Lists all available and registered commands<\/p>\r <p class=\"span-x-2\">create:model {FullyQualifiedNameSpace}<\/p>\r <p>Creates a model in the specified namespace<\/p>\r <p class=\"span-x-2\">create:controller {FullyQualifiedNameSpace}<\/p>\r <p>Creates a routable in the specified namespace<\/p>\r <p class=\"span-x-2\">migrate:model {mysql | sqlite} {FullyQualifiedNameSpace} [-o {output-folder}] [--with-copy]<\/p>\r <p>Migrates a model towards the database. Additionally, a dump (copy) and a migration file (if output folder is set) can be generated<\/p>\r <p class=\"span-x-2\">migrate:models {mysql | sqlite} {NameSpaceToExplore} [-o {output-folder}] [--with-copy]<\/p>\r <p>Same as above, but the plural indicates that every model within the specified namespace gets migrated.<\/p>\r <\/div>\r <h3>Example (assuming MySql setup)<\/h3>\r <ol>\r <li><code class=\"language-shell\">php create:model App\\Models\\Comment<\/code><\/li>\r <li>Specify properties in generated file as described in <a href=\"\/docs\/models\">Models<\/a><\/li>\r <li><code class=\"language-shell\">php migrate:model mysql App\\Models\\Comment<\/code><\/li>\r <\/ol>\r <blockquote>\r Unlike other frameworks, LENKRAD doesn't require separate migration files. If edge-cases create ambiguities (for example when renaming existing properties),\r data is always left intact and a copy of the previous structure can be consulted.\r <\/blockquote>\r <\/div>\r\n<\/section>","headlines":[{"id":"basics","title":"Basic CLI commands","context":"The cli is a powerful helper for your fast-paced reality.\r If you have a setup similar as described in quick-start,\r you should have a working cli execution via php cli.\r The tool is extendable and customizable, so here we are going to focus on an introduction of the most useful and common commands:"}],"url":"\/docs\/cli-basics"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/clitool.html","topic":"cli tool","description":"Advanced CLI introduction\r \r The {{name}} class\r \r \r The {{name}} class...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r\n<!--    url: \/docs\/cli -->\r <h1>CLI Tool<\/h1>\r <p>Advanced CLI introduction<\/p>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-contrast-light\">The {{name}} class<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"class\">The {{name}} class<\/h2>\r <\/div>\r\n<\/section>","headlines":[{"id":"class","title":"The {{name}} class","context":""}],"url":"\/docs\/cli"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/cors.html","topic":"cors","description":"This topic isn't implemented in your version of LENKRAD.   Dealing with cross origin requests?  The CORS class   The CORS class  If required, invoke an instance of the CORS class into your app.  Main methods  Method Description addAllowedOrigin(string $origin) Registers an accepted origin addAllo...","content":"<div> <div version=\"<0.2\" class=\"bg-warning p-2 border-danger border-l-4 relative\"> <p> This topic isn't implemented in your version of LENKRAD. <\/p> <\/div> <section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <!-- url: \/docs\/cors --> <h1>CORS<\/h1> <div version=\"<0.2\" class=\"bg-warning p-2 border-danger border-l-4 relative\"> <p> This topic isn't implemented in your version of LENKRAD. <\/p> <\/div> <p>Dealing with cross origin requests?<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/cors#class\" class=\"button-primary\">The CORS class<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The CORS class<\/h2> <p> If required, invoke an instance of the CORS class into your app. <\/p> <h3>Main methods<\/h3> <div class=\"grid grid-cols-3 gap-3 w-full overflow-x-auto overflow-x-auto\"> <div class=\"border-b-2 border-primary font-lg\">Method<\/div> <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div> <p>addAllowedOrigin(string $origin)<\/p> <p class=\"span-x-2\">Registers an accepted origin<\/p> <p>addAllowedMethod(string $method)<\/p> <p class=\"span-x-2\">Sets an allowed method<\/p> <p>setAllowedMethods(array $allowedMethods)<\/p> <p class=\"span-x-2\">Sets allowed methods<\/p> <p>addAllowedHeader(string $method)<\/p> <p class=\"span-x-2\">Sets an allowed header<\/p> <p>setAllowedHeaders(array $allowedHeaders)<\/p> <p class=\"span-x-2\">Set allowed headers<\/p> <\/div> <h3>Example<\/h3> <pre class=\"normalize-code\"><code class=\"language-php\"> ?php \/\/ \/public\/index.php use Neoan\\NeoanApp; use Neoan\\Routing\\Route; use Neoan\\Helper\\Setup; use Neoan\\Cors\\Cors; ... \/\/ 1. setup cors $cors = new Cors(); $cors->addAllowedOrigin('*') ->setAllowedMethods(['GET','OPTIONS', 'POST', 'PUT']) ->setAllowedHeaders(['Content-Type', 'X-Auth-Token', 'Authorization', 'Origin']) $app = new NeoanApp($setup); \/\/ 2. invoke $app->invoke($cors); \/\/ 3. make instance available for Routables (optional) $app->injectionProvider->set(Cors::class, $cors); ... \/\/ run application $app->run(); <\/code><\/pre> <\/div> <\/section>\n<\/div>","headlines":[{"id":"class","title":"The CORS class","context":"If required, invoke an instance of the CORS class into your app.  Main methods  Method Description addAllowedOrigin(string $origin) Registers an accepted origin"}],"url":"\/docs\/cors"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/customattributes.html","topic":"topic","description":"{{name}} introduction  The {{name}} class   The {{name}} class...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <!-- url: \/route --> <h1>Topic<\/h1> <p>{{name}} introduction<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-primary\">The {{name}} class<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The {{name}} class<\/h2> <\/div>\n<\/section>","headlines":[{"id":"class","title":"The {{name}} class","context":""}],"url":"\/route"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/deploy.html","topic":"deployment","description":"Deployment introduction\r \r The {{name}} class\r \r \r The {{name}} class...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r\n<!--    url: \/docs\/deploy -->\r <h1>Deployment<\/h1>\r <p>Deployment introduction<\/p>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-contrast-light\">The {{name}} class<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"class\">The {{name}} class<\/h2>\r <\/div>\r\n<\/section>","headlines":[{"id":"class","title":"The {{name}} class","context":""}],"url":"\/docs\/deploy"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/dicontainer.html","topic":"dependency injection container","description":"DI introduction\r \r The {{name}} class\r \r \r The {{name}} class...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r\n<!--    url: \/docs\/dependency-injection -->\r <h1>Dependency injection container<\/h1>\r <p>DI introduction<\/p>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-contrast-light\">The {{name}} class<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"class\">The {{name}} class<\/h2>\r <\/div>\r\n<\/section>","headlines":[{"id":"class","title":"The {{name}} class","context":""}],"url":"\/docs\/dependency-injection"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/dynamicstore.html","topic":"dynamic store","description":"Dynamic Store introduction\r \r The {{name}} class\r \r \r The {{name}} class...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r\n<!--    url: \/docs\/dynamic-store -->\r <h1>Dynamic Store<\/h1>\r <p>Dynamic Store introduction<\/p>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-contrast-light\">The {{name}} class<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"class\">The {{name}} class<\/h2>\r <\/div>\r\n<\/section>","headlines":[{"id":"class","title":"The {{name}} class","context":""}],"url":"\/docs\/dynamic-store"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/events.html","topic":"events","description":"Events introduction\r \r The {{name}} class\r \r \r The {{name}} class...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r\n<!--    url: \/docs\/events -->\r <h1>Events<\/h1>\r <p>Events introduction<\/p>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-contrast-light\">The {{name}} class<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"class\">The {{name}} class<\/h2>\r <\/div>\r\n<\/section>","headlines":[{"id":"class","title":"The {{name}} class","context":""}],"url":"\/docs\/events"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/home.html","topic":"getting started","description":"In order to get you set up, you can either create your own setup from scratch (see Quick Start) or use one of the starter projects.  Either way, in order to follow this documentation a working LENKRAD application is necessary.      Quick Start      Starter Projects    Basics  LENKRAD is an all-pur...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <h1>Getting Started<\/h1> <p> In order to get you set up, you can either create your own setup from scratch (see <a href=\"\/quick-start\">Quick Start<\/a>) or use one of the <a href=\"\/starter-projects\">starter projects<\/a>. <br> Either way, in order to follow this documentation a working LENKRAD application is necessary. <\/p> <div class=\"grid grid-cols-2 gap-3 w-3\/5 m-x-auto\"> <div> <a href=\"\/quick-start\" class=\"relative block\"> <svg class=\"\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M17.657 18.657A8 8 0 016.343 7.343S7 9 9 10c0-2 .5-5 2.986-7C14 5 16.09 5.777 17.656 7.343A7.975 7.975 0 0120 13a7.975 7.975 0 01-2.343 5.657z\"><\/path><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9.879 16.121A3 3 0 1012.015 11L11 14H9c0 .768.293 1.536.879 2.121z\"><\/path><\/svg> <span class=\"bg-neutral absolute text-center left-0 bottom-0 w-full border-l-2 border-primary\">Quick Start<\/span> <\/a> <\/div> <div> <a href=\"\/starter-projects\" class=\"relative block\"> <svg fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13 10V3L4 14h7v7l9-11h-7z\"><\/path><\/svg> <span class=\"bg-neutral absolute text-center left-0 bottom-0 w-full border-l-2 border-accent\">Starter Projects<\/span> <\/a> <\/div> <\/div> <h2>Basics<\/h2> <p> LENKRAD is an all-purpose framework, but we are going to concentrate on two of the most common use-cases in web development: <\/p> <ul> <li>API - a backend for your powerful frontend, app or embedded software<\/li> <li>SSR - A all-in-one monolith to generate anything from your personal site to your SAAS business<\/li> <\/ul> <h2>Cross-referencing<\/h2> <p> LENKRAD is very flexible, injectable and customizable and consists of loosely coupled components. This documentation is therefore prone to \"but in my case it's different\"-situations. Our starter projects are designed to mitigate this issue, but this does not change the fact that one page of this documentation will likely lead you to 3 others. The bad news is: there's a reason we call it a <em>core<\/em> instead of a framework. The good news is: the learning curve is not even half as bad as one might initially think. <\/p> <h2>Get in touch<\/h2> <p> This documentation is a living document inspired by your feedback & questions. If you want to engage, please visit <a href=\"https:\/\/github.com\/sroehrl\/php-lenkrad-docs\/issues\">Github<\/a> (While you are there, don't forget to star) <\/p> <h2>Terminology<\/h2> <p> Sometimes it's necessary to refer to concepts that aren't clear due to conflicting definitions. To avoid confusion as far as possible, we added a glossary: <\/p> <div class=\"grid grid-cols-3 gap-3\"> <div class=\"border-b-2 border-primary font-lg\">Term<\/div> <div class=\"border-b-2 border-primary font-lg\">Description<\/div> <div class=\"border-b-2 border-primary font-lg\">Notes<\/div> <h3 id=\"attributes\">Attributes<\/h3> <p> In PHP, attributes is the name given to what most other languages refer to as <em>annotation<\/em>. The feature was introduced in PHP8 LENKRAD makes heavy use of its capabilities. <\/p> <p> <\/p> <h3 id=\"web-route\">Web-route<\/h3> <p>Refers to a Route answering with markup (HTML) using a template.<\/p> <p>This very page is a web-route.<\/p> <h3 id=\"api-route\">API-route<\/h3> <p>Similarly, an API-route is intended to be machine read.<\/p> <p>LENKRAD's default response-handler defaults to JSON-format.<\/p> <h3 id=\"templating\">Templating<\/h3> <p>Templates are markup-shells (HTML) the rendering process uses to apply data to. <\/p> <p>Demo: click <a href=\"docs?say=HELLO\">here<\/a>, watch the url and then see this: {{say}}<\/p> <h3 id=\"middleware\">Middleware<\/h3> <p> In LENKRAD, this concept can be simplified down to code that is executed before your controller logic applies. Middleware can be chained to facilitate guards (e.g. authentication) or to ensure availability of certain data, permissions etc. <\/p> <p> Middleware normalization is very little opinionated in LENKRAD as execution chains are loosely coupled. <\/p> <h3 id=\"di\">Dependency Injection<\/h3> <p>The concept refers to injecting dependencies rather than coupling them. This is were Interfaces shine.<\/p> <p>LENKRAD has an auto-wire dependency injection. This allows you to inject concrete dependencies automatically as needed.<\/p> <\/div>\n<\/section>","headlines":[{"id":"attributes","title":"Attributes","context":"In PHP, attributes is the name given to what most other languages refer to as annotation. The feature was introduced in PHP8 LENKRAD makes heavy use of its capabilities.    Web-route Refers to a Route answering with markup (HTML) using a template. This very page is a web-route. API-route Similarly, an API-rou"},{"id":"web-route","title":"Web-route","context":"Refers to a Route answering with markup (HTML) using a template. This very page is a web-route. API-route Similarly, an API-route is intended to be machine read. LENKRAD's default response-handler defaults to JSON-format. Templating Templates are markup-shells (HTML) the rendering process uses to apply data to."},{"id":"api-route","title":"API-route","context":"Similarly, an API-route is intended to be machine read. LENKRAD's default response-handler defaults to JSON-format. Templating Templates are markup-shells (HTML) the rendering process uses to apply data to.  Demo: click here, watch the url and then see this: {{say}} Middleware  In LENKRAD"},{"id":"templating","title":"Templating","context":"Templates are markup-shells (HTML) the rendering process uses to apply data to.  Demo: click here, watch the url and then see this: {{say}} Middleware  In LENKRAD, this concept can be simplified down to code that is executed before your controller logic applies. Middleware can be chained to facilitate guards (e.g. authenticati"},{"id":"middleware","title":"Middleware","context":"In LENKRAD, this concept can be simplified down to code that is executed before your controller logic applies. Middleware can be chained to facilitate guards (e.g. authentication) or to ensure availability of certain data, permissions etc.   Middleware normalization is very little opinionated in LENKRAD as execution chains are loosely coupled.  Dependency Injection"},{"id":"di","title":"Dependency Injection","context":"The concept refers to injecting dependencies rather than coupling them. This is were Interfaces shine. LENKRAD has an auto-wire dependency injection. This allows you to inject concrete dependencies automatically as needed."}],"url":"\/docs"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/in-development.html","topic":"\n    ","description":"working on it     This page or section is currently being worked on or under review. Please check back soon......","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <h1 class=\"grid grid-cols-3\" > <svg style=\"max-width: 100px\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-6 h-6\"> <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6.75 7.5l3 2.25-3 2.25m4.5 0h3m-9 8.25h13.5A2.25 2.25 0 0021 18V6a2.25 2.25 0 00-2.25-2.25H5.25A2.25 2.25 0 003 6v12a2.25 2.25 0 002.25 2.25z\" \/> <\/svg> <span class=\"span-x-2 place-center-auto\"> We're working on it <\/span> <\/h1> <div class=\"bg-warning p-5 border-danger border-l-4 relative\"> <p class=\"font-lg\"> This page or section is currently being worked on or under review. Please check back soon... <\/p> <\/div> <\/section>","headlines":[],"url":"\/docs"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/middleware.html","topic":"middleware","description":"Middleware chaining is an important concept when working with LENKRAD.\r We are going to focus on routable classes here.\r \r \r Concept\r Loading middleware\r \r \r Concept\r \r Middleware classes in routes need to implement \\Neoan\\Routing\\Interfaces\\Routable and be invokable\r (using an __invoke-method)....","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r\n<!--    url: \/docs\/middleware -->\r <h1>Middleware<\/h1>\r <p>\r Middleware chaining is an important concept when working with LENKRAD.\r We are going to focus on routable classes here.\r <\/p>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/middleware#concept\" class=\"button-contrast-light\">Concept<\/a>\r <a href=\"\/docs\/middleware#loading\" class=\"button-contrast-light\">Loading middleware<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"concept\">Concept<\/h2>\r <p>\r Middleware classes in routes need to implement <em>\\Neoan\\Routing\\Interfaces\\Routable<\/em> and be invokable\r (using an __invoke-method). Middleware can be chained and is commonly used for route-guards or retrieval of repetitive information (e.g. current user).\r <\/p>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"loading\">Loading middleware<\/h2>\r <p>\r When using Attributes\r <\/p>\r <\/div>\r\n<\/section>","headlines":[{"id":"concept","title":"Concept","context":"Middleware classes in routes need to implement \\Neoan\\Routing\\Interfaces\\Routable and be invokable\r (using an __invoke-method). Middleware can be chained and is commonly used for route-guards or retrieval of repetitive information (e.g. current user).\r \r \r \r Loading middleware\r \r When u"},{"id":"loading","title":"Loading middleware","context":"When using Attributes"}],"url":"\/docs\/middleware"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/models.html","topic":"models","description":"Models are the heart and soul of dealing with persistent data.\r LENKRAD has a sophisticated ORM automation to deal with this common topic.\r This means that when we talk about models, we always talk about databases as well.\r \r \r The Model class\r Defining a model\r Collections\r Using a model\r Pagin...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r\n<!--    url: \/docs\/models -->\r <h1>Models<\/h1>\r <p>\r Models are the heart and soul of dealing with persistent data.\r LENKRAD has a sophisticated ORM automation to deal with this common topic.\r This means that when we talk about models, we always talk about databases as well.\r <\/p>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/models#class\" class=\"button-contrast-light\">The Model class<\/a>\r <a href=\"\/docs\/models#define\" class=\"button-contrast-light\">Defining a model<\/a>\r <a href=\"\/docs\/models#collections\" class=\"button-contrast-light\">Collections<\/a>\r <a href=\"\/docs\/models#usage\" class=\"button-contrast-light\">Using a model<\/a>\r <a href=\"\/docs\/models#pagination\" class=\"button-contrast-light\">Pagination<\/a>\r <a href=\"\/docs\/models#magic\" class=\"button-contrast-light\">Magic methods<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"class\">The Model class<\/h2>\r <p>\r LENKRAD uses one file to declare and interact with models. This includes:\r <\/p>\r <ul>\r <li>Database interactions<\/li>\r <li>Database migrations<\/li>\r <li>Object relational mapping<\/li>\r <\/ul>\r <p>A new instance of this model now has the following <em>static<\/em> methods available:<\/p>\r <div class=\"grid grid-cols-3 gap-3\">\r <div class=\"border-b-2 border-primary font-lg span-x-2\">Method<\/div>\r <div class=\"border-b-2 border-primary font-lg\">Description<\/div>\r <p class=\"span-x-2\">get(int|string $id)<\/p>\r <p>Retrieves an instance of the model by primary id.<\/p>\r <p class=\"span-x-2\">retrieve(array $condition, array $filter = [])<\/p>\r <p>Returns a <a href=\"\/docs\/models#collections\">collection<\/a><\/p>\r <p class=\"span-x-2\">retrieveOne(array $condition, array $filter = [])<\/p>\r <p>Retrieves an instance of the model based on condition and\/or filter<\/p>\r <p class=\"span-x-2\">retrieveOneOrCreate(array $condition)<\/p>\r <p>If a model with the condition exists, it's retrieved, else it's created.<\/p>\r <p class=\"span-x-2\">paginate(int $page = 1, int $pageSize = 30)<\/p>\r <p>Returns a <a href=\"\/docs\/models#pagination\">Pagination<\/a> instance<\/p>\r <p class=\"span-x-2\">declare()<\/p>\r <p>Returns the structure in a standardized format (mainly to be used for migrations & transactions)<\/p>\r <\/div>\r <p>And the following <em>initiated<\/em> methods:<\/p>\r <div class=\"grid grid-cols-3 gap-3\">\r <div class=\"border-b-2 border-primary font-lg span-x-2\">Method<\/div>\r <div class=\"border-b-2 border-primary font-lg\">Description<\/div>\r <p class=\"span-x-2\">store()<\/p>\r <p>Executes database transaction(s) to store model changes.<\/p>\r <p class=\"span-x-2\">delete(bool $hard = false)<\/p>\r <p>Soft or hard deletes the mapped entity.<\/p>\r <p class=\"span-x-2\">toArray()<\/p>\r <p>Converts the model object to an assoc array<\/p>\r <p class=\"span-x-2\">rehydrate()<\/p>\r <p>Refills (resets) the instance with database driven values<\/p>\r <p class=\"span-x-2\">getTransactionMode()<\/p>\r <p>Returns the TransactionType enum currently active (INSERT | UPDATE)<\/p>\r <p class=\"span-x-2\">setTransactionMode(TransactionType $type)<\/p>\r <p>Overrides the internal transaction mode.<\/p>\r <p class=\"span-x-2\">__call()<\/p>\r <p>See <a href=\"\/docs\/models#magic\">Magic methods<\/a><\/p>\r <\/div>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"define\">Defining a Model<\/h2>\r <p>\r In order to create a model new, you simply extend the <a href=\"\/docs\/models#class\">Model class<\/a>\r and give it the properties you need.\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r namespace App\\Models;\r use Neoan\\Model\\Model;\r use Neoan\\Model\\Attributes\\IsPrimaryKey;\r use Neoan\\Model\\Attributes\\IsUnique;\r use Neoan\\Model\\Attributes\\Transform;\r use Neoan\\Model\\Transformers\\Hash;\r class User extends Model\r {\r #[IsPrimaryKey]\r public int $id;\r #[IsUnique]\r public string $email;\r public string $userName;\r #[Transform(Hash::class)]\r public string $password;\r }\r <\/code><\/pre>\r <h3>Default & Custom Types<\/h3>\r <p>\r Depending on the database adapter you use (see <a href=\"\/quick-start\">Quick Start<\/a>),\r your PHP types will translate into a default column type. For example, the recommended MySQL adapter\r will assume a string to be <em>varchar<\/em> with the length of 255, a PHP integer to be <em>int<\/em> with a\r length\r of 11 and so on. If you want to influence this behavior, you can use attributes to do so. The generic\r attribute\r <em>Type<\/em> allows you to be very specific as well:\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ...\r use Neoan\\Model\\Transformers\\Type;\r ...\r #[Type('LONGTEXT')]\r public $post;\r ...\r <\/code><\/pre>\r <p>\r The following model attributes are shipped with LENKRAD\r <\/p>\r <div class=\"grid grid-cols-2 gap-3\">\r <div class=\"border-b-2 border-primary font-lg\">Attribute<\/div>\r <div class=\"border-b-2 border-primary font-lg\">Description<\/div>\r <p>HasMany(string $modelName, array $matchingRule = [])<\/p>\r <p>Enables automatic loading of one-to-many relationships by attaching a <a href=\"\/docs\/models#collections\">collection<\/a>\r <\/p>\r <p>Ignore<\/p>\r <p>Signifies a property that shall be ignored by database transactions.<\/p>\r <p>Initialize(mixed $setter)<\/p>\r <p>Attaches a value or instance to the model at creation. (For example a date-converter)<\/p>\r <p>IsForeignKey(string $table, string $property, string $modelName)<\/p>\r <p>Enhances relationship lookup performance and enables <a href=\"\/docs\/models#magic\">magic relationships<\/a>\r <\/p>\r <p>IsPrimaryKey<\/p>\r <p>REQUIRED! Indicates the index of a model for many operations.<\/p>\r <p>IsUnique<\/p>\r <p>handles UNIQUE constraints<\/p>\r <p>Transform(string $transformerClass)<\/p>\r <p>\r Generic hook for transforming values bi- or one-directional (own transformers must implement\r Neoan\\Model\\Interfaces\\Transformation).\r LENKRAD ships with the transformers <em>Hash<\/em> and <em>CurrentTimeIn<\/em> out of the box.\r <\/p>\r <p>Type(string $type, int $length = null, string $default = null)<\/p>\r <p>As discussed, enables custom column-type-matching<\/p>\r <\/div>\r <h3>Constants<\/h3>\r <p>\r To escape further default behavior, constants are used. With new Projects, there shouldn't\r be any necessity for that.\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r const tableName = 'user_table';\r <\/code><\/pre>\r <div class=\"grid grid-cols-2 gap-3\">\r <div class=\"border-b-2 border-primary font-lg\">Constant<\/div>\r <div class=\"border-b-2 border-primary font-lg\">Description<\/div>\r <p>tableName<\/p>\r <p>Overrides the usage of the class name as the table name.<\/p>\r <\/div>\r <h3>Traits<\/h3>\r <p>\r To simplify data structure, traits offer an easy way to escape duplication. LENKRAD offers the following\r model traits out of the box:\r <\/p>\r <div class=\"grid grid-cols-3 gap-3\">\r <div class=\"border-b-2 border-primary font-lg\">Trait<\/div>\r <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div>\r <p>Setter<\/p>\r <p class=\"span-x-2\">\r Enables the model to deal with private and\/or readonly properties.\r It also exposes the method <em>set(string $propertyName, mixed $value)<\/em>\r to the model.\r <\/p>\r <p>TimeStamps<\/p>\r <p class=\"span-x-2\">\r Shorthand for the common fields <strong>createdAt, updatedAt, and deletedAt<\/strong>.\r In addition to allowing for soft-deletion, this trait handles time format transformations.\r <\/p>\r <\/div>\r <h3>Full Example<\/h3>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r namespace App\\Models;\r use Neoan\\Model\\Model;\r use Neoan\\Model\\Attributes\\IsPrimaryKey;\r use Neoan\\Model\\Attributes\\IsUnique;\r use Neoan\\Model\\Attributes\\Transform;\r use Neoan\\Model\\Transformers\\Hash;\r use Neoan\\Model\\Traits\\Setter;\r use Neoan\\Model\\Traits\\TimeStamps;\r class User extends Model\r {\r #[IsPrimaryKey]\r public readonly int $id;\r #[IsUnique]\r public string $email;\r public string $userName;\r #[Transform(Hash::class)]\r public string $password;\r use Setter;\r use TimeStamps;\r }\r <\/code><\/pre>\r <h3>Migration<\/h3>\r <p>\r Creating and updating tables according to your model must be done whenever changes to your\r model declaration have been conducted. The <a href=\"\/docs\/cli-basics\">cli tool<\/a> makes this possible using\r one command.\r <\/p>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"collections\">Collections<\/h2>\r <p>\r A collection instance is useful when dealing with multiple different instances of a given model.\r This is commonly the case when retrieving multiple entries. A collection is iterable and offers useful\r methods:\r <\/p>\r <div class=\"grid grid-cols-3 gap-3\">\r <div class=\"border-b-2 border-primary font-lg\">Method<\/div>\r <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div>\r <p>each(fn)<\/p>\r <p class=\"span-x-2\">\r Expects a closure or invokable while iterating over the instances.\r <\/p>\r <p>add(Model $instance)<\/p>\r <p class=\"span-x-2\">\r Manually adds an instance to the collection.\r <\/p>\r <p>toArray<\/p>\r <p class=\"span-x-2\">\r Returns all entries as one array.\r <\/p>\r <p>store<\/p>\r <p class=\"span-x-2\">\r Runs store commands for all instances contained in the collection (beware of performance!).\r <\/p>\r <p>count<\/p>\r <p class=\"span-x-2\">\r Returns an integer with the number of held model instances.\r <\/p>\r <\/div>\r <h3>Examples<\/h3>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r \/\/ this is an example, please don't take this seriously:\r \/\/ return all users as collection\r $userCollection = User::retrieve();\r \/\/ a collection is iterable:\r foreach($userCollection as $userInstance){\r ...\r }\r \/\/ but you likely want to make use of typing\r $userCollection->each(function(User $user){\r if(str_ends_with($user->email, '@protonmail.com')) {\r $this->sendSecureEmail($user);\r }\r });\r \/\/ how many users?\r $registeredUsers = $userCollection->count();\r \/\/ add a new user\r if($registeredUsers &lt; $this->marketingGoal) {\r for($i = 0; $i &lt; $this->marketingGoal - $registeredUsers; $i++) {\r $bot = new User([\r 'email' => \"myspam+{$i}@gmail.com\",\r 'userName' => 'bot-' . $i,\r 'password' => 'you-wish-800-' . $i\r ]);\r $userCollection->add($bot);\r }\r }\r \/\/ since we got ALL users, this could take a while...\r $userCollection->store();\r <\/code><\/pre>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"usage\">Using a model<\/h2>\r <h3>Retrieval<\/h3>\r <h4 class=\"font-md\">Conditions<\/h4>\r <p>\r Let's begin by exploring how conditions work.\r Conditions are passed into a model as assoc arrays\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r $condition = [\r 'email' => 'adam@email.com'\r ];\r $user = User::retrieveOne($condition);\r <\/code><\/pre>\r <p>\r With the MySQL adapter, this roughly translates to <br>\r <code>SELECT * FROM user WHERE email = \"adam@email.com\"<\/code>.\r Roughly, as in reality queries are optimized and executed as prepared statements.\r The following examples should help you to read & write conditions:\r <\/p>\r <div class=\"grid grid-cols-3 gap-3\">\r <div class=\"border-b-2 border-primary font-lg\">Array<\/div>\r <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div>\r <p>['email' => '%@email.com']<\/p>\r <p class=\"span-x-2\">Retrieve where email ends with \"@email\"<\/p>\r <p>['id' => '>100']<\/p>\r <p class=\"span-x-2\">Retrieve where id is greater than 100<\/p>\r <p>['userName' => '!adam']<\/p>\r <p class=\"span-x-2\">Retrieve where userName is not \"adam\"<\/p>\r <p>['updatedAt' => '!']<\/p>\r <p class=\"span-x-2\">Retrieve where updatedAt is not NULL (aka WHERE the record was updated at least\r once)<\/p>\r <p>['deletedAt' => null] or simply ['^deletedAt']<\/p>\r <p class=\"span-x-2\">Retrieve where deletedAt is NULL (aka undeleted entries)<\/p>\r <\/div>\r <p>\r Conditions are chained as <em>AND<\/em>, so <br>\r <code>['email' => '%@email.com', 'userName' => '!adam']<\/code> <br>\r retrieves records that meet both criteria.\r <\/p>\r <h4 class=\"font-md\">Filters<\/h4>\r <p>\r Both shipped adapters currently only provide two filters:\r <\/p>\r <div class=\"grid grid-cols-2 gap-3\">\r <div class=\"border-b-2 border-primary font-lg\">Filter<\/div>\r <div class=\"border-b-2 border-primary font-lg\">Description<\/div>\r <p>orderBy => [string $property, string $ascOrDesc]<\/p>\r <p>Influences the sorting order of results<\/p>\r <p>limit => [int $offset, int $rowCount]<\/p>\r <p>Paginates results<\/p>\r <\/div>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r $filter = [\r 'orderBy' => ['userName', 'desc'],\r 'limit' => [0,10]\r ];\r $user = User::retrieve([], $filter);\r <\/code><\/pre>\r <p>\r This would return 10 entries sorted by userName in reverse alphabetical order.\r <\/p>\r <blockquote>\r Note: If you are worried about limited complexity, rest assured that\r direct usage of the Database class can handle any potential bottleneck.\r <\/blockquote>\r <h4 class=\"font-md\">Security<\/h4>\r <p>\r Conditions are matched against the structure and type of a given model and transactions are executed as\r prepared statements.\r This annihilates user-input concerns.\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r \/\/ yes, this is save to do\r $postedInput = Request::getInputs();\r $user = User::retrieveOne($postedInput);\r <\/code><\/pre>\r <h3>Create<\/h3>\r <p>\r Creating a new model entry is as straight forward as it can be:\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r \/\/ as empty instance\r $user = new User();\r \/\/ write\r $user->userName = 'Adam'; \/\/ if type is correct, will set\r \/\/ or directly with values passed as array\r $user = new User(['userName' => 'Adam']);\r \/\/ read\r echo $user->userName; \/\/ \"Adam\"\r \/\/ write\r $user->userName = 'Ben'; \/\/ overrides old value\r try{\r $user->store();\r } catch(\\Exception $e) {\r \/\/ ups... some properties are neither nullable nor have a default value\r \/\/ so we have to set email & password\r }\r $user->password = '123123';\r $user->email = 'ben@email.com';\r \/\/ if a setter is used you can also do:\r $user->set('password', '123123')\r ->set('email', 'ben@email.com');\r $user->store();\r \/\/ after database transaction, we have an id (or other primary key)!\r $userId = $user->id;\r <\/code><\/pre>\r <h3>Update<\/h3>\r <p>\r Updating an entry is no different from creation.\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r $user = User::retrieveOne(['email' => 'ben@email.com']);\r \/\/ rename\r $user->userName = 'Benjamin';\r \/\/ save changes to db\r $user->store();\r <\/code><\/pre>\r <h3>Collection properties<\/h3>\r <p>\r If you looked at the attribute-section of <a href=\"\/docs\/models#class\">the model class<\/a>,\r you might have noticed the <em>HasMany<\/em>-attribute. In a real world scenario, one might have two models:\r <\/p>\r <p>Movie model<\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r namespace App\\Models;\r use Neoan\\Model\\Model;\r use Neoan\\Model\\Collection;\r use Neoan\\Model\\Attributes\\IsPrimaryKey;\r use Neoan\\Model\\Attributes\\HasMany;\r use Neoan\\Model\\Traits\\TimeStamps;\r class Movie extends Model\r {\r #[IsPrimaryKey]\r public int $id;\r public string $name;\r #[HasMany(Rating::class)]\r public Collection $ratings;\r use TimeStamps;\r }\r <\/code><\/pre>\r <p>Rating model<\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r namespace App\\Models;\r use Neoan\\Model\\Model;\r use Neoan\\Model\\Collection;\r use Neoan\\Model\\Attributes\\IsPrimaryKey;\r use Neoan\\Model\\Attributes\\IsForeignKey;\r use Neoan\\Model\\Traits\\TimeStamps;\r class Rating extends Model\r {\r #[IsPrimaryKey]\r public int $id;\r #[IsForeignKey('movie', 'id')]\r public int $movieId;\r public int $rating;\r use TimeStamps;\r }\r <\/code><\/pre>\r <p>\r The result when retrieving movies now has ratings automatically attached.\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r $movie = Movie::get(1);\r \/\/ the property ratings is already a filled collection\r $numberOfRatings = $movie->ratings->count();\r <\/code><\/pre>\r <p>\r Be aware that automatically attaching large numbers of rows can lead to performance\r issues. Since a model is just a class, you can always optimize by providing own methods:\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ...\r class Movie extends Model\r {\r ...\r public ratings(): Collection\r {\r return Rating::retrieve(['movieId' => $this->id]);\r }\r }\r <\/code><\/pre>\r <p>And then use them accordingly:<\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r $movie = Movie::get(1);\r \/\/ the property ratings is already a filled collection\r $numberOfRatings = $movie->ratings()->count();\r <\/code><\/pre>\r <p>Have a look at <a href=\"\/docs\/models#magic\">Magic methods<\/a> for how one-to-one relationships are automated for this.<\/p>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"pagination\">Pagination<\/h2>\r <p>\r Pagination is a common task when dealing with lists and\/or large numbers of expected results.\r LENKRAD simplified this process.\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r $page = 1;\r $resultsPerPage = 25;\r return User::paginate($page, $resultsPerPage)\r \/\/ you can use the regular condition array to specify\r ->where(['^deletedAt])\r \/\/ newest users first? Let's get the last ids first\r ->descending('id')\r \/\/ when you're done specifying, execute\r ->get();\r <\/code><\/pre>\r <p>\r The response of a pagination call is standardized and returns the structure:\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r [\r 'page' => 1,    \/\/ current page\r 'total' => 48,      \/\/ total hits\r 'pageSize' => 25,       \/\/ number of results per page\r 'pages' => 2,       \/\/ total number of resulting pages\r 'collection' => `{Collection}`      \/\/ result as Collection\r ]\r <\/code><\/pre>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"magic\">Magic methods<\/h2>\r <p>\r LENKRAD avoids magic methods as we believe in empowering your IDE to do its job without having to\r write comments like it's 2015. However, models DO have a __call-implementation and attributes can make use of it.\r Out of the box, the attribute <em>IsForeignKey<\/em> uses it. Let's revive our movie class and add the property \"director\"\r to see it in action:\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r namespace App\\Models;\r use Neoan\\Model\\Model;\r use Neoan\\Model\\Collection;\r use Neoan\\Model\\Attributes\\IsPrimaryKey;\r use Neoan\\Model\\Attributes\\IsForeignKey;\r use Neoan\\Model\\Attributes\\HasMany;\r use Neoan\\Model\\Traits\\TimeStamps;\r class Movie extends Model\r {\r #[IsPrimaryKey]\r public int $id;\r public string $name;\r #[HasMany(Rating::class)]\r public Collection $ratings;\r \/\/ let's pretend we have a model \"Director\"\r #[IsForeignKey('director','id', Director::class)]\r public int $directorId;\r use TimeStamps;\r \/\/ Bonus: let's add a static helper after noticing we tend to\r \/\/ always get movies by name, but for some reason programmatically\r \/\/ (In reality one would likely notice that this is rarely necessary)\r public static function byName( string $name): ?self\r {\r return self::retrieveOne(['name' => $name]);\r }\r }\r <\/code><\/pre>\r <p>\r In action:\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r $movie = Movie::byName('Avatar');\r \/\/ Of course we have the directorId available\r $directorId = $movie->directorId;\r \/\/ now let's get the associated director!\r if($directorId === $movie->director()->id){\r \/\/ as you have guessed, we now have the director available\r }\r <\/code><\/pre>\r <blockquote>\r As mentioned, your IDE will not suggest the availability of magic methods.\r Refer to your IDE's guide on how to add magic methods to your suggestions (usually @method)\r <\/blockquote>\r <\/div>\r\n<\/section>","headlines":[{"id":"class","title":"The Model class","context":"LENKRAD uses one file to declare and interact with models. This includes:\r \r \r Database interactions\r Database migrations\r Object relational mapping\r \r A new instance of this model now has the following static methods available:\r \r Method"},{"id":"define","title":"Defining a Model","context":"In order to create a model new, you simply extend the Model class\r and give it the properties you need.\r \r \r namespace App\\Models;\r use Neoan\\Model\\Model;\r use Neoan\\Model\\Attributes\\IsPrimaryKey;\r use Neoan\\Model\\Attributes\\IsUnique;\r use Neoan\\Model\\Attributes\\Transform;\r use Neoan\\Model\\Transforme"},{"id":"collections","title":"Collections","context":"A collection instance is useful when dealing with multiple different instances of a given model.\r This is commonly the case when retrieving multiple entries. A collection is iterable and offers useful\r methods:\r \r \r Method\r Description"},{"id":"usage","title":"Using a model","context":"Retrieval\r Conditions\r \r Let's begin by exploring how conditions work.\r Conditions are passed into a model as assoc arrays\r \r \r $condition = [\r 'email' => 'adam@email.com'\r ];\r $user = User::retrieveOne($condition);\r \r \r With the MySQL adapter, this roughly translates to \r SE"},{"id":"pagination","title":"Pagination","context":"Pagination is a common task when dealing with lists and\/or large numbers of expected results.\r LENKRAD simplified this process.\r \r \r $page = 1;\r $resultsPerPage = 25;\r return User::paginate($page, $resultsPerPage)\r \/\/ you can use the regular condition array to specify\r ->where(['^deletedAt])\r \/\/ newest users first? Let's get the las"},{"id":"magic","title":"Magic methods","context":"LENKRAD avoids magic methods as we believe in empowering your IDE to do its job without having to\r write comments like it's 2015. However, models DO have a __call-implementation and attributes can make use of it.\r Out of the box, the attribute IsForeignKey uses it. Let's revive our movie class and add the property \"director\"\r to see it in action:"}],"url":"\/docs\/models"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/request.html","topic":"request","description":"General flow  Request    Your logic    Response  Where it all begins...  The Request class Request Unit Testing Using Request   The Request class  As reacting on requests is likely the most common prerequisite to your programmatic logic, LENKRAD has made handling requests as easy as possible. Let's...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\n<!--    url: \/docs\/request --> <h1>Request<\/h1> <h2>General flow<\/h2> <div class=\"grid grid-cols-5 mb-5 gap-x-2\"> <div class=\"bg-contrast p-2 border-accent border-r-2\">Request<\/div> <div class=\"border-neutral-light border-t-1  place-center-stretch relative\"> <div class=\"absolute border-neutral-light border-t-1 border-r-1 p-1 right-0\" style=\"transform: rotate(45deg); top: -0.4rem\"><\/div> <\/div> <div class=\"bg-contrast p-2\">Your logic<\/div> <div class=\"border-neutral-light border-t-1 place-center-stretch relative\"> <div class=\"absolute border-neutral-light border-t-1 border-r-1 p-1 right-0\" style=\"transform: rotate(45deg); top: -0.4rem\"><\/div> <\/div> <div class=\"bg-contrast p-2\">Response<\/div> <\/div> <p>Where it all begins...<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/request#class\" class=\"button-contrast-light\">The Request class<\/a> <a href=\"\/docs\/request#request-test\" class=\"button-contrast-light\">Request Unit Testing<\/a> <a href=\"\/docs\/request#usage\" class=\"button-contrast-light\">Using Request<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The Request class<\/h2> <p> As reacting on requests is likely the most common prerequisite to your programmatic logic, LENKRAD has made handling requests as easy as possible. Let's first look at the static public methods: <\/p> <div class=\"grid grid-cols-2 gap-3\"> <div class=\"border-b-2 border-primary font-lg\">Method<\/div> <div class=\"border-b-2 border-primary font-lg\">Description<\/div> <p>Request::getQueries()<\/p> <p>Returns assoc array of query parameters<\/p> <p>Request::getQuery(string $name)<\/p> <p>Return the value of the specified query parameter, or null<\/p> <p>Request::getRequestMethod()<\/p> <p>Returns a Neoan\\Enums\\RequestMethod case<\/p> <p>Request::getRequestUri()<\/p> <p>Returns a string containing the request-uri<\/p> <p>Request::getInputs()<\/p> <p>Returns client-payload, regardless of method<\/p> <p>Request::getInput(string $name)<\/p> <p>Returns the value of the specified input, or null<\/p> <p>Request::getParameters()<\/p> <p>Returns assoc array of route-specific parameters (see <a href=\"\/docs\/routing#parameter\">Route parameter<\/a>)<\/p> <p>Request::getParameter(string $name)<\/p> <p>Returns the value of the specified parameter, or null<\/p> <p>Request::getInstance(Request $mockInstance = null)<\/p> <p>Return the current instance of the Request facade. (e.g. to mock & test)<\/p> <\/div> <p>Additionally, some useful properties are public:<\/p> <code class=\"language-php block\">$request = Request::getInstance();<\/code> <div class=\"grid grid-cols-2 gap-3 mt-3\"> <div class=\"border-b-2 border-primary font-lg\">Property<\/div> <div class=\"border-b-2 border-primary font-lg\">Description<\/div> <p>$request->requestHeaders<\/p> <p>Array containing all collected headers<\/p> <p>$request->files<\/p> <p>Array containing all files submitted via form-data<\/p> <p>$request->webPath<\/p> <p>Returns string of actual webPath before any sanitation and parsing<\/p> <\/div> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"request-test\">Request Unit Testing<\/h2> <p> To ease testing of your application code, you can set\/override values at runtime. This is true for all public properties. Additionally, the following setters work statically: <\/p> <div class=\"grid grid-cols-2 gap-3\"> <div class=\"border-b-2 border-primary font-lg\">Method<\/div> <div class=\"border-b-2 border-primary font-lg\">Description<\/div> <p>Request::setParameters(array $parameters)<\/p> <p>Expects assoc array<\/p> <p>Request::setQueries(array $queryParameters)<\/p> <p>Expects assoc array<\/p> <p>Request::detachInstance()<\/p> <p>Resets the singleton to null. (NOTE: you likely want to run getInstance() with a mock-instance after that to generate a new instance)<\/p> <\/div> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"usage\">Using Request<\/h2> <p> You <em>must not<\/em> inject the Request into your controllers. Instead, the static methods can be used after app-instantiation anywhere in your code. <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> ... use Neoan\\Request\\Request; class RandomClass extends Routable { public function __invoke(MyValidationClass $validation) { [ 'terms-accepted' => $accepted, 'email' => $requesterEmail ] = Request::getInputs(); if(!$accepted || !$validation->isValidEmail($requesterEmail)){ $this->doSomething(); } $this->addToNewsletter($requesterEmail); Response::redirect('\/dashboard') } ... } <\/code><\/pre> <\/div>\n<\/section>","headlines":[{"id":"class","title":"The Request class","context":"As reacting on requests is likely the most common prerequisite to your programmatic logic, LENKRAD has made handling requests as easy as possible. Let's first look at the static public methods:   Method Description Request::getQueries() Re"},{"id":"request-test","title":"Request Unit Testing","context":"To ease testing of your application code, you can set\/override values at runtime. This is true for all public properties. Additionally, the following setters work statically:   Method Description Request::setParameters(array $parameters) E"},{"id":"usage","title":"Using Request","context":"You must not inject the Request into your controllers. Instead, the static methods can be used after app-instantiation anywhere in your code.   ... use Neoan\\Request\\Request; class RandomClass extends Routable { public function __invoke(MyValidationClass $validation) { [ 'terms-accepted' => $accepted, 'email' => $requesterEma"}],"url":"\/docs\/request"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/response.html","topic":"response","description":"General flow  Request    Your logic    Response   In most scenarios, you won't interact with the Response class directly after your defaults have been set up.   The Response class Setting defaults   The Response class  The Response class is used by internal processes to handle the http-answer. When...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\n<!--    url \/docs\/response --> <h1>Response<\/h1> <h2>General flow<\/h2> <div class=\"grid grid-cols-5 mb-5 gap-x-2\"> <div class=\"bg-contrast p-2\">Request<\/div> <div class=\"border-neutral-light border-t-1  place-center-stretch relative\"> <div class=\"absolute border-neutral-light border-t-1 border-r-1 p-1 right-0\" style=\"transform: rotate(45deg); top: -0.4rem\"><\/div> <\/div> <div class=\"bg-contrast p-2\">Your logic<\/div> <div class=\"border-neutral-light border-t-1 place-center-stretch relative\"> <div class=\"absolute border-neutral-light border-t-1 border-r-1 p-1 right-0\" style=\"transform: rotate(45deg); top: -0.4rem\"><\/div> <\/div> <div class=\"bg-contrast p-2 border-accent border-r-2\">Response<\/div> <\/div> <p> In most scenarios, you won't interact with the Response class directly after your defaults have been set up. <\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/response#class\" class=\"button-contrast-light\">The Response class<\/a> <a href=\"\/docs\/response#response-defaults\" class=\"button-contrast-light\">Setting defaults<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The Response class<\/h2> <p> The Response class is used by internal processes to handle the http-answer. When the last class implementing Routable in your logic chain returns, the Route class automatically passes the accumulated results to the output defined in the current <a href=\"\/docs\/routing\">route<\/a> or based on <a href=\"\/docs\/response#response-defaults\">your settings<\/a>. Like any other part of LENKRAD, the process is fully exposed to you. The Response class offers the following static methods: <\/p> <div class=\"grid grid-cols-2 gap-3\"> <div class=\"border-b-2 border-primary font-lg\">Method<\/div> <div class=\"border-b-2 border-primary font-lg\">Description<\/div> <p>setDefaultOutput(ResponseOutput $output)<\/p> <p>Takes a Neoan\\Enums\\ResponseOutput case. The default is ResponseOutput::JSON<\/p> <p>output($data, array $renderOptions)<\/p> <p>Manually triggers immediate output with given specifications<\/p> <p>getDefaultOutput()<\/p> <p>Returns default Neoan\\Enums\\ResponseOutput case<\/p> <p>setDefaultRenderer(string $renderer)<\/p> <p> Expects classname of class implementing Neoan\\Render\\RenderEngine. (You can set alternative Renderers at a route-level as well) <\/p> <p>json(Serializable $data)<\/p> <p> Serializes provided data to json and responds immediately (with corresponding header). Method gets called internally if defaultOutput is set to ResponseOutput::JSON <\/p> <p> html(mixed $data, ?string $view) <\/p> <p> Normalizes $data (DataNormalization instance), applies it to provided view and immediately responds with output. Method gets called internally if defaultOutput is set to ResponseOutput::HTML <\/p> <p> setStatuscode(int $httpResponseCode) <\/p> <p> Sets response code in response header. <\/p> <p> redirect(string $whereTo) <\/p> <p> Redirects to specified location and stops execution. <\/p> <p> getInstance(?ResponseInterface = null) <\/p> <p>Returns Response instance. A mock response can be passed in (for testing)<\/p> <p>detachInstance()<\/p> <p>Resets singleton instance.<\/p> <\/div> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"response-defaults\">Setting defaults<\/h2> <p> If you are <a href=\"\/docs\/routing#attribute\">routing by attributes<\/a>, there are no default settings you need to worry about regarding the response. If you define your routes classically, you might want to simplify your route definitions by setting a default for the most common case of route. <\/p> <h3>Server Side Rendered Application<\/h3> <p>If your routes tend to be rendered pages, consider <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> use Neoan\\Response\\Response; use Neoan\\Enums\\ResponseOutput; Response::setDefaultOutput(ResponseOutput::HTML) <\/code><\/pre> <h3>JSON API<\/h3> <p>If you are building a pure backend, consider<\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> use Neoan\\Response\\Response; use Neoan\\Enums\\ResponseOutput; Response::setDefaultOutput(ResponseOutput::JSON); <\/code><\/pre> <blockquote> You can always overwrite the response-type on the route level. <\/blockquote> <h3>Programmatic example<\/h3> <pre class=\"normalize-code\"><code class=\"language-php\"> use Neoan\\Response\\Response; use Neoan\\Request\\Request; use Neoan\\Enums\\ResponseOutput; \/\/ In a monolith, we might have api-routes and web-routes $isApi = str_starts_with(Request::getRequestUri(), '\/api\/'); Response::setDefaultOutput($isApi ? ResponseOutput::JSON : ResponseOutput::HTML); <\/code><\/pre> <\/div>\n<\/section>","headlines":[{"id":"class","title":"The Response class","context":"The Response class is used by internal processes to handle the http-answer. When the last class implementing Routable in your logic chain returns, the Route class automatically passes the accumulated results to the output defined in the current route or based on your settings. Like any other part of LENKRAD, the proces"},{"id":"response-defaults","title":"Setting defaults","context":"If you are routing by attributes, there are no default settings you need to worry about regarding the response. If you define your routes classically, you might want to simplify your route definitions by setting a default for the most common case of route.  Server Side Rendered Application If your routes tend to be rendered pages, consider"}],"url":"\/docs"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/routing.html","topic":"routing","description":"Routing of endpoints can be handled by attribute or declaration. This page will explain both.  The Route class Middleware Chaining Route Parameters Direct Injections Custom Response Handling Attribute Routing   The Route class  Like most core-classes, Route is used statically while maintaining a si...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\n<!--  url: \/docs\/routing  --> <h1>Routing<\/h1> <p>Routing of endpoints can be handled by attribute or declaration. This page will explain both.<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/routing#class\" class=\"button-contrast-light\">The Route class<\/a> <a href=\"\/docs\/routing#chaining\" class=\"button-contrast-light\">Middleware Chaining<\/a> <a href=\"\/docs\/routing#parameter\" class=\"button-contrast-light\">Route Parameters<\/a> <a href=\"\/docs\/routing#inject\" class=\"button-contrast-light\">Direct Injections<\/a> <a href=\"\/docs\/routing#response\" class=\"button-contrast-light\">Custom Response Handling<\/a> <a href=\"\/docs\/routing#attribute\" class=\"button-contrast-light\">Attribute Routing<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The Route class<\/h2> <p> Like most core-classes, <em>Route<\/em> is used statically while maintaining a single instance of itself. It's responsible for registering routes. <\/p> <h3>Main methods<\/h3> <div class=\"grid grid-cols-3 gap-3 w-full overflow-x-auto overflow-x-auto\"> <div class=\"border-b-2 border-primary font-lg\">Method<\/div> <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div> <p>Route::get<\/p> <p class=\"span-x-2\">Registers a GET request<\/p> <p>Route::post<\/p> <p class=\"span-x-2\">Registers a POST request<\/p> <p>Route::put<\/p> <p class=\"span-x-2\">Registers a PUT request<\/p> <p>Route::patch<\/p> <p class=\"span-x-2\">Registers a PATCH request<\/p> <p>Route::delete<\/p> <p class=\"span-x-2\">Registers a DELETE request<\/p> <p>Route::request<\/p> <p class=\"span-x-2\">Registers other\/custom requests<\/p> <\/div> <p> With the exception of <em>Route::request<\/em>, these methods all take the same arguments. LENKRAD intends to work with your IDE and tries to reduce string usage by the user. For these methods, this means that classnames are provided to a route. A class must fulfill the following requirements:  <\/p> <ul> <li>Implements Neoan\\Routing\\Interfaces\\Routable<\/li> <li>Has __invoke method<\/li> <li>Returns a serializable result, a <a href=\"\/docs\/models\">Model, a Collection<\/a> or a DataNormalization instance<\/li> <\/ul> <h3>Example or a routable class<\/h3> <pre class=\"normalize-code\"><code class=\"language-php\"> ?php namespace App; use Neoan\\Routing\\Interfaces\\Routable; class Controller implements Routable { public function __invoke(): array { return ['test' => 'message']; } } <\/code><\/pre> <h3>Example of a route using <em>Controller.php<\/em><\/h3> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App; use Neoan\\Routing\\Route; Route::get('\/test', Controller::class); <\/code><\/pre> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"chaining\">Middleware Chaining<\/h2> <p>A route definition can chain routable classes as needed:<\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App; use Neoan\\Routing\\Route; Route::get('\/test', Auth::class, ReadUserFile::class, Controller::class); <\/code><\/pre> <p>This will execute one class after another. For a better understanding on how to utilize this feature, please refer to the <a href=\"\/docs\/middleware\">Middleware chapter<\/a> of this documentation<\/p> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"parameter\">Route parameter<\/h2> <p> In both API & SSR routes, variable parameters are a common necessity. Like many other frameworks in various languages, LENKRAD solves this by markup: <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App; use Neoan\\Routing\\Route; \/\/ Route will respond to \/test\/{anything} Route::get('\/test\/:name', Controller::class); \/\/ Route will respond to \/test and \/test\/{anything} Route::get('\/test\/:name*', Controller::class); \/\/ Multiple parameters are possible Route::get('\/test\/:name\/:id*', Controller::class); <\/code><\/pre> <h3>Variable usage<\/h3> <p> Routes using parameters provide their content to <a href=\"\/docs\/request\">Request<\/a>. To indicate a part of the route as parameter, prefix it with <em>: (colon)<\/em>. To indicate a part of the route is an optional parameter, additionally append it with <em>* (asterisks)<\/em> <\/p> <blockquote> Careful when chaining parameters. It's a common trap to pollute namespaces. <\/blockquote> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"inject\">Direct Injection<\/h2> <p> In very simple projects or routes, the necessity for logic might be overkill. You can therefore directly pass values to the response instead of using a class. <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App; use Neoan\\Routing\\Route; use Neoan\\Request\\Request; Route::get('\/test\/:name') ->inject(Request::getParameters()); <\/code><\/pre> <blockquote> Note that without additional changes to defaults, this only works for the standard JSON response. <\/blockquote> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"response\">Custom response handling<\/h2> <p> We speak of an either\/or when talking about responses. However, in reality you might have different response requirements for a particular route. This is why it's possible to overwrite the default behavior per route. <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App; use Neoan\\Routing\\Route; use Neoan\\Response\\Response; \/\/ using the default response handler, but overwriting its current default handling Route::get('\/test', Controller::class) ->view('templates\/test.html') ->response([Response::class,'html']); \/\/ using your own response handler and its method \"answer\" Route::get('\/test', Controller::class) ->response([MyResponseHandler::class,'answer']); <\/code><\/pre> Response handling is further explained in <a href=\"\/docs\/response\">Response<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"attribute\">Attribute Routing<\/h2> <p> Ever since Ruby on Rails exploded onto the world, annotational routing took the developer's interest. In LENKRAD, you can achieve this with attributes on the class-level. <\/p> <h3>Setup<\/h3> <p> In order to make use of this convenient way of defining routes, add the following lines to your index.php in your public folder: <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> ... $app = new NeoanApp( $appPath, $publicPath, $cliPath); \/\/ enable attribute routing $namespaceToExploreRecursively = 'App'; $app->invoke(new Neoan\\Routing\\AttributeRouting($namespaceToExploreRecursively)); $app->run(); <\/code><\/pre> <h3>Examples<\/h3> <div class=\"grid grid-cols-6 gap-3 w-full overflow-x-auto\"> <div class=\"border-b-2 border-primary font-lg\">Attribute<\/div> <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div> <div class=\"border-b-2 border-primary font-lg span-x-3\">Example<\/div> <p>Web<\/p> <p class=\"span-x-2\">Resolves html routes<\/p> <p class=\"span-x-3\">#[Web('\/test', 'test.html')]<\/p> <p>Get<\/p> <p class=\"span-x-2\">Resolves API-GET routes<\/p> <p class=\"span-x-3\">#[Get('\/api\/test')]<\/p> <p>Post<\/p> <p class=\"span-x-2\">Resolves API-GET routes<\/p> <p class=\"span-x-3\">#[Post('\/api\/test', AuthGuard::class)]<\/p> <p>Put<\/p> <p class=\"span-x-2\">Resolves API-PUT routes<\/p> <p class=\"span-x-3\">#[Put('\/api\/test', AuthGuard::class)]<\/p> <\/div> <p> Generally, the behavior is identical to declaring routes manually. <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> ?php namespace App; \/\/ Don't forget the use-statement! use Neoan\\Routing\\Attributes\\Get; use Neoan\\Routing\\Interfaces\\Routable; #[Get('\/api\/test')] class Controller implements Routable { public function __invoke(): array { return ['test' => 'message']; } } <\/code><\/pre> <\/div> <\/section>","headlines":[{"id":"class","title":"The Route class","context":"Like most core-classes, Route is used statically while maintaining a single instance of itself. It's responsible for registering routes.  Main methods  Method Description Route::ge"},{"id":"chaining","title":"Middleware Chaining","context":"A route definition can chain routable classes as needed:  namespace App; use Neoan\\Routing\\Route; Route::get('\/test', Auth::class, ReadUserFile::class, Controller::class);  This will execute one class after another. For a better understanding on how to utilize this feature, please refer to the"},{"id":"parameter","title":"Route parameter","context":"In both API & SSR routes, variable parameters are a common necessity. Like many other frameworks in various languages, LENKRAD solves this by markup:   namespace App; use Neoan\\Routing\\Route; \/\/ Route will respond to \/test\/{anything} Route::get('\/test\/:name', Controller::class); \/\/ Route will respond to \/test and \/test\/{anything} Rout"},{"id":"inject","title":"Direct Injection","context":"In very simple projects or routes, the necessity for logic might be overkill. You can therefore directly pass values to the response instead of using a class.   namespace App; use Neoan\\Routing\\Route; use Neoan\\Request\\Request; Route::get('\/test\/:name') ->inject(Request::getParameters());   Note that without a"},{"id":"response","title":"Custom response handling","context":"We speak of an either\/or when talking about responses. However, in reality you might have different response requirements for a particular route. This is why it's possible to overwrite the default behavior per route.   namespace App; use Neoan\\Routing\\Route; use Neoan\\Response\\Response; \/\/ using the default response handler, but overw"},{"id":"attribute","title":"Attribute Routing","context":"Ever since Ruby on Rails exploded onto the world, annotational routing took the developer's interest. In LENKRAD, you can achieve this with attributes on the class-level.  Setup  In order to make use of this convenient way of defining routes, add the following lines to your index.php in your public folder:   ... $app ="}],"url":"\/docs\/routing"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/setup.html","topic":"setup","description":"Unifying common setup necessities  The Setup class   The Setup class  Starting from version v0.2, the app requires an instance of the setup-helper. This simplifies the setup process greatly.  Main methods  Method Description set(string $key, mixed $value) Registers a value available throughout the...","content":"<div> <div version=\"<0.2\" class=\"bg-warning p-2 border-danger border-l-4 relative\"> <p> This topic isn't implemented in your version of LENKRAD. <\/p> <\/div> <section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <!-- url: \/docs\/setup --> <h1>Setup<\/h1> <p>Unifying common setup necessities<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-primary\">The Setup class<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The Setup class<\/h2> <p> Starting from version v0.2, the app requires an instance of the setup-helper. This simplifies the setup process greatly. <\/p> <h3>Main methods<\/h3> <div class=\"grid grid-cols-3 gap-3 w-full overflow-x-auto overflow-x-auto\"> <div class=\"border-b-2 border-primary font-lg\">Method<\/div> <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div> <p>set(string $key, mixed $value)<\/p> <p class=\"span-x-2\">Registers a value available throughout the app<\/p> <p>get(string $key)<\/p> <p class=\"span-x-2\">Retrieves a value<\/p> <p>getConfiguration()<\/p> <p class=\"span-x-2\">Retrieves an array of all setup values<\/p> <p>setPublicPath(string $path)<\/p> <p class=\"span-x-2\">Registers web-path<\/p> <p>setLibraryPath(string $path)<\/p> <p class=\"span-x-2\">Registers source-path<\/p> <p>setDatabaseAdapter(Adapter $adapter)<\/p> <p class=\"span-x-2\">Accepts instantiated Database adapter<\/p> <p>setSkeletonVariables(array $skeletonVariables)<\/p> <p class=\"span-x-2\">See <a href=\"\/docs\/templating?highlight=skeletonVariables\">templating (variables)<\/a><\/p> <p>setSkeletonComponentPlacement(string $skeletonComponentPlacement)<\/p> <p class=\"span-x-2\">See <a href=\"\/docs\/templating?highlight=placement\">templating (placement)<\/a><\/p> <p>setSkeletonHTML(string $skeletonHTML)<\/p> <p class=\"span-x-2\">See <a href=\"\/docs\/templating?highlight=skeletonPath\">templating (skeleton)<\/a><\/p> <p>setUseSkeleton(bool $useSkeleton)<\/p> <p class=\"span-x-2\">Set true for use of layout\/frame mode<\/p> <p>setDefault404(string $default404)<\/p> <p class=\"span-x-2\">Set own 404 page html<\/p> <p>setDefault500(string $default500)<\/p> <p class=\"span-x-2\">Set own system error page html<\/p> <p>setTemplatePath(string $templatePath)<\/p> <p class=\"span-x-2\">Set relative base path for templating<\/p> <\/div> <h3>Example with custom value<\/h3> <p>index.php<\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> ?php \/\/ \/public\/index.php use Neoan\\NeoanApp; use Neoan\\Routing\\Route; use Neoan\\Helper\\Setup; $projectPath = dirname(__DIR__); require_once $projectPath . '\/vendor\/autoload.php'; $pathToSourceFiles = $projectPath . '\/src'; $publicPath = __DIR__; $setup = new Setup(); $setup->setLibraryPath($pathToSourceFiles) ->setPublicPath($publicPath) \/\/ some arbitrary setup value ->set('globalArray', ['a']); $app = new NeoanApp($setup); ... \/\/ run application $app->run(); <\/code><\/pre> <p>Some controller<\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> ?php namespace App; use Neoan\\Routing\\Interfaces\\Routable; use Neoan\\Helper\\Setup; class Controller implements Routable { \/\/ auto-wire our setup instance public function __invoke(Setup $setup): array { \/\/ let's return our globalArray return $setup->get('globalArray'); } } <\/code><\/pre> <\/div> <\/section>\n<\/div>\n","headlines":[{"id":"class","title":"The Setup class","context":"Starting from version v0.2, the app requires an instance of the setup-helper. This simplifies the setup process greatly.  Main methods  Method Description set(string $key, mixed $value)"}],"url":"\/docs\/setup"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/templating.html","topic":"templating & rendering","description":"Rendering & templating in LENKRAD - the basics\r \r About rendering\r The Render class\r The Templating class\r \r \r About rendering\r \r It's important to understand how LENKRAD handles rendering in general. This page assumes that the default\r Renderer is used. Please refer to Response and Custom respons...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r <!--    url: \/docs\/templating -->\r <h1>Templating & Rendering<\/h1>\r <p>Rendering & templating in LENKRAD - the basics<\/p>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/templating#ssr\" class=\"button-contrast-light\">About rendering<\/a>\r <a href=\"\/docs\/templating#render\" class=\"button-contrast-light\">The Render class<\/a>\r <a href=\"\/docs\/templating#class\" class=\"button-contrast-light\">The Templating class<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"ssr\">About rendering<\/h2>\r <p>\r It's important to understand how LENKRAD handles rendering in general. This page assumes that the default\r Renderer is used. Please refer to <a href=\"\/docs\/response\">Response<\/a> and <a\r href=\"\/docs\/routing#response\">Custom response handling<\/a>\r for possibilities to influence rendering.\r <\/p>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"render\">The Render class<\/h2>\r <p>\r The Renderer class has the following static methods:\r <\/p>\r <div class=\"grid grid-cols-2 gap-3\">\r <div class=\"border-b-2 border-primary font-lg\">Method<\/div>\r <div class=\"border-b-2 border-primary font-lg\">Description<\/div>\r <p>setTemplatePath(string $path)<\/p>\r <p>Sets the entry level of template-arguments<\/p>\r <p>getInstance(Renderer $mockInstance = null)<\/p>\r <p>Returns an existing instance if present, creates a new instance if initial or overrides the used instance\r with a mock instance (testing)<\/p>\r <p>setHtmlSkeleton(string $skeletonPath, string $placement = 'main', array $skeletonVariables = [])<\/p>\r <p>See example below<\/p>\r <p>render(array | DataNormalization $data, $view)<\/p>\r <p>Manually triggers rendering (used automatically on last procedural chain, you likely will never need\r it)<\/p>\r <p>detachInstance()<\/p>\r <p>Resets internal singleton to null<\/p>\r <p>getTemplatePath()<\/p>\r <p>Returns string with set template path<\/p>\r <p>getHtmlSkeletonPath()<\/p>\r <p>Returns string of set skeleton path<\/p>\r <p>getHtmlComponentPlacement()<\/p>\r <p>Returns string of set component placement<\/p>\r <\/div>\r <p>\r The default rendering class can either be used with individually rendered HTML files or using a surrounding\r layout\r where route-specific content is placed in a predefined container. Here, we assume the latter, also referred\r to as skeleton setup.\r <\/p>\r <h3 id=\"#skeleton-structure\">Skeleton structure<\/h3>\r <div class=\"m-t-5 m-b-5 border-neutral-light border-1 p-4 relative\">\r <p class=\"font-md absolute -top-5 bg-neutral pl-2 pr-2\">\/src\/views\/skeleton.html<\/p>\r <p>This file contains the \"frame\"-html. Maybe header, menus, footer, etc.<\/p>\r <div class=\"m-t-5 m-b-5 border-primary-dark border-1 p-4 relative\">\r <p class=\"font-md absolute -top-5 bg-neutral pl-2 pr-2\">Respective component\/route HTML<\/p>\r <p>The render class places the route's defined HTML at a specified location (defaults to \"main\")<\/p>\r <\/div>\r <\/div>\r <p>The method <em>setHtmlSkeleton<\/em> is best explained by example.<\/p>\r <h3>Example<\/h3>\r <p>1. \/src\/views\/skeleton.html (regarding the curly bracket markup, see <a href=\"\/docs\/templating#class\">the\r Template class<\/a>)<\/p>\r <pre class=\"normalize-code\"><code class=\"language-html\" data-class=\"strip-html\" data-id=\"skeleton\"><\/code><\/pre>\r <p>2. \/src\/Home\/Home.php<\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ?php\r namespace App\\Home;\r use Neoan\\Routing\\Interfaces\\Routable;\r class Home implements Routable\r {\r public function __invoke(): array\r {\r return ['fromHome' => 'Hello there, Obi Wan Kenobi']\r }\r }\r <\/code><\/pre>\r <p>3. \/src\/Home\/view.html<\/p>\r <pre class=\"normalize-code\"><code class=\"language-html\" data-class=\"strip-html\" data-id=\"view\"><\/code><\/pre>\r <p>4. \/public\/index.php<\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r use Neoan\\NeoanApp;\r use Neoan\\Routing\\Route;\r use Neoan\\Render\\Renderer;\r use Neoan\\Enums\\ResponseOutput;\r use Neoan\\Response\\Response;\r use App\\Home\\Home;\r $projectPath = dirname(__DIR__);\r require_once $projectPath . '\/vendor\/autoload.php';\r $pathToSourceFiles = $projectPath . '\/src';\r $publicPath = __DIR__;\r $app = new NeoanApp($pathToSourceFiles, $publicPath);\r \/\/ to simplify our life, let's set this app to default to SSR ...\r Response::setDefaultOutput(ResponseOutput::HTML);\r \/\/ ... and set a default entry path for our views\r Renderer::setTemplatePath('src\/');\r \/\/ Let's set up our skeleton\r Renderer::setHtmlSkeleton(\r 'src\/views\/skeleton.html', \/\/ our skeleton HTML\r 'main',     \/\/ our component placement\r [\r 'year' => '2022',\r 'title' => 'My App'\r ]           \/\/ lastly, we can set default variables used in our skeleton\r );\r \/\/ register a test route\r Route::get('\/', Home::class)->view('Home\/view.html');\r \/\/ run application\r $app->run();\r <\/code><\/pre>\r <blockquote>\r We're lumping everything in the index file to show everything at one glance.\r Feel free to have a look at our starter projects to get suggestions of how to structure your\r real-life project.\r <\/blockquote>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"class\">The Template class<\/h2>\r <p>\r LENKRAD ships with <a href=\"https:\/\/packagist.org\/packages\/neoan3-apps\/template\">neoan3-apps\/template<\/a> as\r the default\r templating mechanism. Documentation for the package is provided, so here we only provide a very basic\r example to get\r you started.\r <\/p>\r <h3>e.g. in \/src\/MyRoute\/MyRoute.php<\/h3>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ...\r #[Web('\/my-route', '\/MyRoute\/view.html')]\r class MyRoute implements Routable\r {\r public function __invoke(NeoanApp $app): array\r {\r $search = new Search();\r \/\/ Let's spoof a search\r Request::setQueries(['query' => 'model']);\r return [\r 'boolean' => true,\r 'results' => $search($app)['sections'],\r 'today' => date('m\/d\/Y')\r ];\r }\r }\r <\/code><\/pre>\r <h3>e.g. in \/src\/MyRoute\/view.html<\/h3>\r <pre class=\"normalize-code\"><code class=\"language-html\" data-class=\"strip-html\"\r data-id=\"one\">\r <\/code><\/pre>\r <h3>Result<\/h3>\r <div class=\"bg-contrast p-3\">\r <section>\r <h1 n-if=\"boolean\">{{today}}<\/h1>\r <\/section>\r <table>\r <tr n-for=\"results as result\">\r <td><a href=\"{{result.link}}\">{{result.link}}<\/a><\/td>\r <td>{{result.headline}}<\/td>\r <\/tr>\r <\/table>\r <\/div>\r <p>\r For translations and internationalization, you can use PHP's gettext or a package like\r <a href=\"https:\/\/github.com\/sroehrl\/php-i18n-translate#readme\">php-i18n-translate<\/a>\r <\/p>\r <\/div>\r <script type=\"text\/html\" id=\"one\">\r &lt;section&gt;\r &lt;!-- n-if: element removed if not true --&gt;\r &lt;!-- NOTE: can only have one child (element or text-node) --&gt;\r &lt;h1 n-if=\"boolean\"&gt;&#123;&#123;today}}&lt;\/h1&gt;\r &lt;\/section&gt;\r &lt;table&gt;\r &lt;!-- n-for: iterates similar to foreach --&gt;\r &lt;tr n-for=\"results as result\"&gt;\r &lt;!-- substitutions work in attributes as well --&gt;\r &lt;td&gt;&lt;a href=\"&#123;&#123;result.link}}\"&gt;&#123;&#123;result.link}}&lt;\/a&gt;&lt;\/td&gt;\r &lt;td&gt;&#123;&#123;result.headline}}&lt;\/td&gt;\r &lt;\/tr&gt;\r &lt;\/table&gt;\r <\/script>\r <script type=\"text\/html\" id=\"skeleton\">\r &lt;!DOCTYPE html&gt;\r &lt;html lang=\"en\"&gt;\r &lt;head&gt;\r &lt;meta charset=\"UTF-8\"&gt;\r &lt;title&gt;&#123;&#123;title}}&lt;\/title&gt;\r &lt;\/head&gt;\r &lt;body&gt;\r &lt;div class=\"p-3\"&gt;\r &#123;&#123;main}}\r &lt;\/div&gt;\r &lt;footer&gt;&copy; &#123;&#123;year}}&lt;\/footer&gt;\r &lt;\/body&gt;\r <\/script>\r <script type=\"text\/html\" id=\"view\">\r &lt;div class=\"bg-warning\"&gt;\r &#123;&#123;fromHome}}\r &lt;\/div&gt;\r <\/script>\r\n<\/section>","headlines":[{"id":"ssr","title":"About rendering","context":"It's important to understand how LENKRAD handles rendering in general. This page assumes that the default\r Renderer is used. Please refer to Response and Custom response handling\r for possibilities to influence rendering.\r \r \r \r The Rende"},{"id":"render","title":"The Render class","context":"The Renderer class has the following static methods:\r \r \r Method\r Description\r setTemplatePath(string $path)\r Sets the entry level of template-arguments\r getInstance(Renderer $mockInstance = null)\r Returns an existing insta"},{"id":"#skeleton-structure","title":"Skeleton structure","context":"\/src\/views\/skeleton.html\r This file contains the \"frame\"-html. Maybe header, menus, footer, etc.\r \r Respective component\/route HTML"},{"id":"class","title":"The Template class","context":"LENKRAD ships with neoan3-apps\/template as\r the default\r templating mechanism. Documentation for the package is provided, so here we only provide a very basic\r example to get\r you started.\r \r e.g. in \/src\/MyRoute\/MyRoute.php\r \r ...\r #[Web('\/my-route', '\/MyRou"}],"url":"\/docs\/templating"}]