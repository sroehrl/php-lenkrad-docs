[{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/clibasics.html","topic":"cli basics","description":"Basic CLI commands\r \r Basic CLI commands\r \r \r Basic CLI commands\r \r The cli is a powerful helper for your fast-paced reality.\r If you have a setup similar as described in quick-start,\r you should have a working cli execution via php cli.\r The tool is extendable and customizable, so here we are goi...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r\n<!--    url: \/docs\/cli-basics -->\r <h1>CLI Basics<\/h1>\r <p>Basic CLI commands<\/p>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/cli-basics\/#basics\" class=\"button-primary\">Basic CLI commands<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"basics\">Basic CLI commands<\/h2>\r <p>\r The cli is a powerful helper for your fast-paced reality.\r If you have a setup similar as described in <a href=\"\/quick-start#cli\">quick-start<\/a>,\r you should have a working cli execution via <code class=\"language-shell\">php cli<\/code>.\r The tool is extendable and customizable, so here we are going to focus on an introduction of the most useful and common commands:\r <\/p>\r <div class=\"grid grid-cols-3 gap-3\">\r <div class=\"border-b-2 border-primary font-lg span-x-2\">Command<\/div>\r <div class=\"border-b-2 border-primary font-lg\">Description<\/div>\r <p class=\"span-x-2\">list<\/p>\r <p>Lists all available and registered commands<\/p>\r <p class=\"span-x-2\">create:model {FullyQualifiedNameSpace}<\/p>\r <p>Creates a model in the specified namespace<\/p>\r <p class=\"span-x-2\">create:controller {FullyQualifiedNameSpace}<\/p>\r <p>Creates a routable in the specified namespace<\/p>\r <p class=\"span-x-2\">create:request {FullyQualifiedNameSpace}<\/p>\r <p>Creates a request guard in the specified namespace<\/p>\r <p class=\"span-x-2\">migrate:model {mysql | sqlite} {FullyQualifiedNameSpace} [-o {output-folder}] [--with-copy]<\/p>\r <p>Migrates a model towards the database. Additionally, a dump (copy) and a migration file (if output folder is set) can be generated<\/p>\r <p class=\"span-x-2\">migrate:models {mysql | sqlite} {NameSpaceToExplore} [-o {output-folder}] [--with-copy]<\/p>\r <p>Same as above, but the plural indicates that every model within the specified namespace gets migrated.<\/p>\r <\/div>\r <h3>Example (assuming MySql setup)<\/h3>\r <ol>\r <li><code class=\"language-shell\">php create:model App\\Models\\Comment<\/code><\/li>\r <li>Specify properties in generated file as described in <a href=\"\/docs\/models\">Models<\/a><\/li>\r <li><code class=\"language-shell\">php migrate:model mysql App\\Models\\Comment<\/code><\/li>\r <\/ol>\r <blockquote>\r Unlike other frameworks, LENKRAD doesn't require separate migration files. If edge-cases create ambiguities (for example when renaming existing properties),\r data is always left intact and a copy of the previous structure can be consulted.\r <\/blockquote>\r <\/div>\r\n<\/section>","headlines":[{"id":"basics","title":"Basic CLI commands","context":"The cli is a powerful helper for your fast-paced reality.\r If you have a setup similar as described in quick-start,\r you should have a working cli execution via php cli.\r The tool is extendable and customizable, so here we are going to focus on an introduction of the most useful and common commands:"}],"url":"\/docs\/cli-basics"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/clitool.html","topic":"cli tool","description":"Advanced CLI introduction\r \r Commands\r \r \r Commands\r \r Lenkrad uses the Symfony console to facilitate CLI commands.\r It's wise to head over to the package's documentation, but for our purposes, here's a quick example using this documentation's custom route generator:\r \r \r namespace Configuration;...","content":"<div>\r <section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r <!--    url: \/docs\/cli -->\r <h1>CLI Tool<\/h1>\r <p>Advanced CLI introduction<\/p>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/cli#commands\" class=\"button-contrast-light\">Commands<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"commands\">Commands<\/h2>\r <p>\r Lenkrad uses the <a href=\"https:\/\/symfony.com\/doc\/current\/components\/console.html\">Symfony console<\/a> to facilitate CLI commands.\r It's wise to head over to the package's documentation, but for our purposes, here's a quick example using this documentation's custom route generator:\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r namespace Configuration;\r use Neoan\\Cli\\Create\\FileCreator;\r use Neoan\\NeoanApp;\r use Symfony\\Component\\Console\\Attribute\\AsCommand;\r use Symfony\\Component\\Console\\Command\\Command;\r use Symfony\\Component\\Console\\Input\\InputArgument;\r use Symfony\\Component\\Console\\Input\\InputInterface;\r use Symfony\\Component\\Console\\Output\\OutputInterface;\r #[\r AsCommand(\r 'create:webroute',\r 'Starter: Creates file implementing Routable'\r )]\r class WebRouteCommand extends Command\r {\r private NeoanApp $neoanApp;\r \/\/ should you need the core instance, you can pass it in\r public function __construct(NeoanApp $neoanApp, string $name = null)\r {\r $this->neoanApp = $neoanApp;\r parent::__construct($name);\r }\r \/\/ see https:\/\/symfony.com\/doc\/current\/console.html#configuring-the-command\r protected function configure()\r {\r $this\r ->addArgument(\r 'name',\r InputArgument::REQUIRED,\r 'fully qualified namespace'\r );\r }\r \/\/ see https:\/\/symfony.com\/doc\/current\/console.html#creating-a-command\r protected function execute(InputInterface $input, OutputInterface $output): int\r {\r FileCreator::process('controller', $input->getArgument('name'), $this->neoanApp, $output);\r $viewTemplate = file_get_contents($this->neoanApp->cliPath . '\/.templates\/ViewTemplate.html');\r $nameParts = explode('\\\\', $input->getArgument('name'));\r file_put_contents($this->neoanApp->appPath . '\/views\/docs\/' . strtolower(end($nameParts)) . '.html', $viewTemplate);\r return Command::SUCCESS;\r }\r }\r <\/code><\/pre>\r <p>In order to register the command, open the file \"cli\" (or wherever you or your starter package placed the cli command) and load it.<\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r use Configuration\\WebRouteCommand;\r use Neoan\\Cli\\Application;\r use Neoan\\Helper\\Setup;\r use Neoan\\NeoanApp;\r require_once __DIR__ . '\/vendor\/autoload.php';\r $setup = new Setup();\r $setup->setPublicPath(__DIR__ . '\/public')\r ->setLibraryPath(__DIR__ . '\/src');\r $app = new NeoanApp($setup, __DIR__);\r $console = new Application($app);\r \/\/ add your command(s)\r $console->add(new WebRouteCommand($app));\r $console->run();\r <\/code><\/pre>\r <\/div>\r <\/section>\r\n<\/div>\r\n","headlines":[{"id":"commands","title":"Commands","context":"Lenkrad uses the Symfony console to facilitate CLI commands.\r It's wise to head over to the package's documentation, but for our purposes, here's a quick example using this documentation's custom route generator:\r \r \r namespace Configuration;\r use Neoan\\Cli\\Create"}],"url":"\/docs\/cli"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/cors.html","topic":"cors","description":"This topic isn't implemented in your version of LENKRAD.   Dealing with cross origin requests?  The CORS class   The CORS class  If required, invoke an instance of the CORS class into your app.  Main methods  Method Description addAllowedOrigin(string $origin) Registers an accepted origin addAllo...","content":"<div> <div version=\"<0.2\" class=\"bg-warning p-2 border-danger border-l-4 relative\"> <p> This topic isn't implemented in your version of LENKRAD. <\/p> <\/div> <section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <!-- url: \/docs\/cors --> <h1>CORS<\/h1> <div version=\"<0.2\" class=\"bg-warning p-2 border-danger border-l-4 relative\"> <p> This topic isn't implemented in your version of LENKRAD. <\/p> <\/div> <p>Dealing with cross origin requests?<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/cors#class\" class=\"button-primary\">The CORS class<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The CORS class<\/h2> <p> If required, invoke an instance of the CORS class into your app. <\/p> <h3>Main methods<\/h3> <div class=\"grid grid-cols-3 gap-3 w-full overflow-x-auto overflow-x-auto\"> <div class=\"border-b-2 border-primary font-lg\">Method<\/div> <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div> <p>addAllowedOrigin(string $origin)<\/p> <p class=\"span-x-2\">Registers an accepted origin<\/p> <p>addAllowedMethod(string $method)<\/p> <p class=\"span-x-2\">Sets an allowed method<\/p> <p>setAllowedMethods(array $allowedMethods)<\/p> <p class=\"span-x-2\">Sets allowed methods<\/p> <p>addAllowedHeader(string $method)<\/p> <p class=\"span-x-2\">Sets an allowed header<\/p> <p>setAllowedHeaders(array $allowedHeaders)<\/p> <p class=\"span-x-2\">Set allowed headers<\/p> <\/div> <h3>Example<\/h3> <pre class=\"normalize-code\"><code class=\"language-php\"> ?php \/\/ \/public\/index.php use Neoan\\NeoanApp; use Neoan\\Routing\\Route; use Neoan\\Helper\\Setup; use Neoan\\Cors\\Cors; ... \/\/ 1. setup cors $cors = new Cors(); $cors->addAllowedOrigin('*') ->setAllowedMethods(['GET','OPTIONS', 'POST', 'PUT']) ->setAllowedHeaders(['Content-Type', 'X-Auth-Token', 'Authorization', 'Origin']) $app = new NeoanApp($setup); \/\/ 2. invoke $app->invoke($cors); \/\/ 3. make instance available for Routables (optional) $app->injectionProvider->set(Cors::class, $cors); ... \/\/ run application $app->run(); <\/code><\/pre> <\/div> <\/section>\n<\/div>","headlines":[{"id":"class","title":"The CORS class","context":"If required, invoke an instance of the CORS class into your app.  Main methods  Method Description addAllowedOrigin(string $origin) Registers an accepted origin"}],"url":"\/docs\/cors"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/customattributes.html","topic":"topic","description":"{{name}} introduction  The {{name}} class   The {{name}} class...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <!-- url: \/route --> <h1>Topic<\/h1> <p>{{name}} introduction<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-primary\">The {{name}} class<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The {{name}} class<\/h2> <\/div>\n<\/section>","headlines":[{"id":"class","title":"The {{name}} class","context":""}],"url":"\/route"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/deploy.html","topic":"deployment","description":"Manual deployment\r Example: AWS EC2\r \r \r Manual deployment\r We are working on various deployment helpers. For now, here is a checklist for manual deployment.\r Checklist initial installation\r \r Apache or Nginx installed and configured?\r PHP and required modules installed?\r Database (MySQL) instal...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r\n<!--    url: \/docs\/deploy -->\r <h1>Deployment<\/h1>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/deploy#manual\" class=\"button-contrast-light\">Manual deployment<\/a>\r <a href=\"\/docs\/deploy#aws-ec2\" class=\"button-contrast-light\">Example: AWS EC2<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"manual\">Manual deployment<\/h2>\r <p>We are working on various deployment helpers. For now, here is a checklist for manual deployment.<\/p>\r <h3>Checklist initial installation<\/h3>\r <ul>\r <li>Apache or Nginx installed and configured?<\/li>\r <li>PHP and required modules installed?<\/li>\r <li>Database (MySQL) installed & configured?<\/li>\r <li>Codebase uploaded?<\/li>\r <li>Domain & SSL set up?<\/li>\r <\/ul>\r <h3>Checklist continuous deployment<\/h3>\r <ul>\r <li>Packages updated?<\/li>\r <li>Models migrated?<\/li>\r <\/ul>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"aws-ec2\">Example: Initial installation on AWS EC2<\/h2>\r <p>If you are using AWS EC2, this could be your first deployment procedure:<\/p>\r <h3>1. Create ec2 instance running Ubuntu (20.04 or higher)<\/h3>\r <p>Store the pem-key & set the security group to accept traffic from anywhere on port 443 and 80.<\/p>\r <h3>2. Log into the instance via ssh<\/h3>\r <p>There are multiple ways of doing so depending on your OS. We recommend using WSL on Windows to unify the instructions for the following procedure.<\/p>\r <p>In your terminal, go to the folder \".ssh\"<\/p>\r <pre class=\"normalize-code\"><code class=\"language-bash\">\r cd ~\/.ssh\r mkdir keys\r cp \/path\/to\/downloaded\/pem-key.pem keys\/pem-key.pem\r chmod 400 keys\/pem-key.pem\r <\/code><\/pre>\r <p>Then, open the file config in vim\/nano or similar and set up the following:<\/p>\r <pre class=\"normalize-code\"><code class=\"language-bash\">\r Host    my-lenkrad-server\r HostName    [public-aws-ip]\r User    ubuntu\r IdentityFile ~\/.ssh\/keys\/pem-key.pem\r <\/code><\/pre>\r <p>You should now be able to ssh into the instance with the command \"ssh my-lenkrad-server\".<\/p>\r <h3>3. Install apache, php, certbot, and mysql<\/h3>\r <p>Once logged into your instance, run the following commands:<\/p>\r <h4>Apache & mysql<\/h4>\r <pre class=\"normalize-code\"><code class=\"language-bash\">\r sudo apt update\r sudo apt install apache2 mysql-server\r sudo mysql_secure_installation\r <\/code><\/pre>\r <blockquote>Consider setting up a dedicated user with restricted permissions<\/blockquote>\r <h4>PHP & modules<\/h4>\r <pre class=\"normalize-code\"><code class=\"language-bash\">\r sudo apt install software-properties-common\r sudo add-apt-repository ppa:ondrej\/php\r sudo apt update\r sudo apt install php8.2 libapache2-mod-php8.2\r sudo apt install php8.2-{mysql,zip,xml,curl}\r sudo service apache2 restart\r <\/code><\/pre>\r <h4>Upload codebase<\/h4>\r <p>Upload your codebase to a folder in \/var\/www.<\/p>\r <h4>Domain setup<\/h4>\r <pre class=\"normalize-code\"><code class=\"language-bash\">\r cd \/etc\/apache2\/sites-available\r sudo cp 000-default.conf my-domain.com.conf\r sudo nano my-domain.com.conf\r <\/code><\/pre>\r <p>Assuming you have a domain pointing to the public IP of your server, you can make the following changes:<\/p>\r <pre class=\"normalize-code\"><code class=\"language-bash\" data-id=\"site\" data-class=\"strip-html\">\r <\/code><\/pre>\r <p>Save the file, then<\/p>\r <pre class=\"normalize-code\"><code class=\"language-bash\">\r sudo a2ensite my-domain.com\r sudo service apache2 restart\r <\/code><\/pre>\r <h4>SSL for free, baby<\/h4>\r <pre class=\"normalize-code\"><code class=\"language-bash\">\r sudo snap install --classic certbot\r sudo ln -s \/snap\/bin\/certbot \/usr\/bin\/certbot\r sudo certbot --apache\r <\/code><\/pre>\r <h4>Setup .env & migrate<\/h4>\r <pre class=\"normalize-code\"><code class=\"language-bash\">\r cd \/var\/www\/YOUR_UPLOAD_FOLDER\r nano .env\r <\/code><\/pre>\r <p>Add needed environment variables and save. You will likely need at least:<\/p>\r <ul>\r <li>DB_NAME<\/li>\r <li>DB_USER<\/li>\r <li>DB_PASSWORD<\/li>\r <li>JWT_SECRET<\/li>\r <li>APPLICATION_ID<\/li>\r <\/ul>\r <p>, but the actual requirements depend on your application.<\/p>\r <p>Lastly, migrate your database<\/p>\r <pre class=\"normalize-code\"><code class=\"language-bash\">\r php cli migrate:models mysql\r <\/code><\/pre>\r <blockquote>Running in a subdirectory of a domain on apache? then don't forget to change the .htaccess file in \/public<\/blockquote>\r <\/div>\r <script type=\"text\/html\" id=\"site\">\r &lt;VirtualHost *:80&gt;\r # The ServerName directive sets the request scheme, hostname and port that\r # the server uses to identify itself. This is used when creating\r # redirection URLs. In the context of virtual hosts, the ServerName\r # specifies what hostname must appear in the request's Host: header to\r # match this virtual host. For the default virtual host (this file) this\r # value is not decisive as it is used as a last resort host regardless.\r # However, you must set it for any further virtual host explicitly.\r #ServerName www.example.com\r ServerName my-domain.com\r ServerAlias www.my-domain.com\r ServerAdmin YOUR_EMAIL@my-domain.com\r DocumentRoot \/var\/www\/YOUR_UPLOAD_FOLDER\/public\r # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,\r # error, crit, alert, emerg.\r # It is also possible to configure the loglevel for particular\r # modules, e.g.\r #LogLevel info ssl:warn\r ErrorLog ${APACHE_LOG_DIR}\/error.log\r CustomLog ${APACHE_LOG_DIR}\/access.log combined\r # For most configuration files from conf-available\/, which are\r # enabled or disabled at a global level, it is possible to\r # include a line for only one particular virtual host. For example the\r # following line enables the CGI configuration for this host only\r # after it has been globally disabled with \"a2disconf\".\r #Include conf-available\/serve-cgi-bin.conf\r &lt;\/VirtualHost&gt;\r <\/script>\r\n<\/section>","headlines":[{"id":"manual","title":"Manual deployment","context":"We are working on various deployment helpers. For now, here is a checklist for manual deployment.\r Checklist initial installation\r \r Apache or Nginx installed and configured?\r PHP and required modules installed?\r Database (MySQL) installed & configured?\r Codebase uploaded?\r Domain & SSL set up?\r \r Checklist continuous depl"},{"id":"aws-ec2","title":"Example: Initial installation on AWS EC2","context":"If you are using AWS EC2, this could be your first deployment procedure:\r 1. Create ec2 instance running Ubuntu (20.04 or higher)\r Store the pem-key & set the security group to accept traffic from anywhere on port 443 and 80.\r 2. Log into the instance via ssh\r There are multiple ways of doing so depending on your OS. We recommend using WSL on Windows to unify t"}],"url":"\/docs\/deploy"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/dicontainer.html","topic":"dependency injection container","description":"Lenkrad uses auto-wiring to enable dependency injection in a convenient way.\r \r \r Concept\r Using the DI-Container\r Manual registration\r Creating an injectable class\r Injecting vs Middleware\r \r \r Concept\r \r The auto-wiring loading mechanism uses existing instances of injected classes or creates a...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r\n<!--    url: \/docs\/dependency-injection -->\r <h1>Dependency injection container<\/h1>\r <p>\r Lenkrad uses auto-wiring to enable dependency injection in a convenient way.\r <\/p>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/dependency-injection#concept\" class=\"button-contrast-light\">Concept<\/a>\r <a href=\"\/docs\/dependency-injection#usage\" class=\"button-contrast-light\">Using the DI-Container<\/a>\r <a href=\"\/docs\/dependency-injection#registration\" class=\"button-contrast-light\">Manual registration<\/a>\r <a href=\"\/docs\/dependency-injection#creation\" class=\"button-contrast-light\">Creating an injectable class<\/a>\r <a href=\"\/docs\/dependency-injection#di-vs-middleware\" class=\"button-contrast-light\">Injecting vs Middleware<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"concept\">Concept<\/h2>\r <p>\r The auto-wiring loading mechanism uses existing instances of injected classes or creates a new instance if\r the current controller is the first member using the class. Some classes are already instantiated by the\r app itself (e.g. Injections, Setup, NeoanApp).\r <\/p>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"usage\">Using the DI-Container<\/h2>\r <p>\r You can automatically inject any class adhering to the following:\r <\/p>\r <ul>\r <li>Has an invoke-method<\/li>\r <li>Invoke-method returns instance of the class itself (singleton)<\/li>\r <\/ul>\r <p>\r Example\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ?php\r namespace App\\MyRoute;\r use Auth;\r use Neoan\\NeoanApp;\r use App\\Middleware\\RequiresAuth;\r class MyRoute implements Routable\r {\r \/\/ simply define your required injections\r public function __invoke(NeoanApp $app, RequiresAuth $authenticated): array\r {\r \/\/ and use them as you please\r return [\r 'web-path' => $app->webPath,\r 'current-user' => $authenticated->user\r ];\r }\r }\r <\/code><\/pre>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"registration\">Manual registration<\/h2>\r <p>\r If you want\/need to ensure the existence of an instance and it's properties,\r you can use the injection provider directly:\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ?php\r use Neoan\\NeoanApp;\r ...\r $app = new NeoanApp($setup);\r $app->injectionProvider->set(App\\MyClass, new App\\MyClass())\r ...\r <\/code><\/pre>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"creation\">Creating an injectable class<\/h2>\r <p>\r To inspire your creativity, let's look at some examples.\r <\/p>\r <p>Example 1: Auth<\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ?php\r namespace App\\Middleware;\r use Neoan\\Routing\\Interfaces\\Routable;\r \/\/ using https:\/\/packagist.org\/packages\/neoan3-apps\/stateless\r use Neoan3\\Apps\\Stateless;\r class Auth implements Routable\r {\r private ?array $auth;\r public function __invoke(): self\r {\r try{\r $this->auth = Stateless::validate();\r } catch (\\Exception $e) {\r $this->auth = null;\r }\r return $this;\r }\r public function isLoggedIn(): bool\r {\r return (bool) $this->auth;\r }\r public function getUserId()\r {\r return $this->auth['id'] ?? null;\r }\r }\r <\/code><\/pre>\r <p>Example 2: Making a model injectable (this is esoteric!)<\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ?php\r namespace App\\User;\r use Neoan\\Model\\Attributes\\IsPrimaryKey;\r use Neoan\\Model\\Model;\r class User extends Model\r {\r #[IsPrimaryKey]\r public int $id;\r ...\r public function __invoke(Auth $auth): static\r {\r $this->rehydrate($auth->getUserId())\r return $this;\r }\r }\r <\/code><\/pre>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"di-vs-middleware\">Injecting vs. Middleware<\/h2>\r <p>\r In these examples, one can see that auto-wiring injections often makes the use of chaining middleware in\r routes redundant. Choosing which path to take is not only a question of preference, however.\r One should take into consideration the project necessities and structure as a whole.\r To help you make that decision, we recommend the following (non-binding) rule:\r <\/p>\r <div class=\"grid grid-cols-2 gap-3\">\r <p><em>Are values passed on?<\/em><\/p>\r <p>Injection is probably the easier approach<\/p>\r <p><em>Is the class conditional towards execution?<\/em><\/p>\r <p>Middleware is probably the easier approach<\/p>\r <p><em>Is both the case?<\/em><\/p>\r <p>Design your class to be used as both and use it simultaneously as middleware and DI<\/p>\r <\/div>\r <\/div>\r\n<\/section>","headlines":[{"id":"concept","title":"Concept","context":"The auto-wiring loading mechanism uses existing instances of injected classes or creates a new instance if\r the current controller is the first member using the class. Some classes are already instantiated by the\r app itself (e.g. Injections, Setup, NeoanApp).\r \r \r \r Using the DI-Container\r \r You"},{"id":"usage","title":"Using the DI-Container","context":"You can automatically inject any class adhering to the following:\r \r \r Has an invoke-method\r Invoke-method returns instance of the class itself (singleton)\r \r \r Example\r \r \r ?php\r namespace App\\MyRoute;\r use Auth;\r use Neoan\\NeoanApp;\r use App\\Middleware\\RequiresAuth;\r class MyRoute implements Routa"},{"id":"registration","title":"Manual registration","context":"If you want\/need to ensure the existence of an instance and it's properties,\r you can use the injection provider directly:\r \r \r ?php\r use Neoan\\NeoanApp;\r ...\r $app = new NeoanApp($setup);\r $app->injectionProvider->set(App\\MyClass, new App\\MyClass())\r ..."},{"id":"creation","title":"Creating an injectable class","context":"To inspire your creativity, let's look at some examples.\r \r Example 1: Auth\r \r ?php\r namespace App\\Middleware;\r use Neoan\\Routing\\Interfaces\\Routable;\r \/\/ using https:\/\/packagist.org\/packages\/neoan3-apps\/stateless\r use Neoan3\\Apps\\Stateless;\r class Auth implements Routable\r {\r private ?array $auth;\r public function __invoke()"},{"id":"di-vs-middleware","title":"Injecting vs. Middleware","context":"In these examples, one can see that auto-wiring injections often makes the use of chaining middleware in\r routes redundant. Choosing which path to take is not only a question of preference, however.\r One should take into consideration the project necessities and structure as a whole.\r To help you make that decision, we recommend the following (non-binding) rule:"}],"url":"\/docs\/dependency-injection"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/dynamicstore.html","topic":"dynamic store","description":"Dynamic Store introduction\r \r The Store class\r The Dynamic class\r \r \r The Neoan\\Store class\r \r The dynamic store is a simple key-value storage meant to be written throughout the procedural execution while being writable and readable until rendering or responding.\r This is useful for default variab...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r\n<!--    url: \/docs\/dynamic-store -->\r <h1>Dynamic Store<\/h1>\r <p>Dynamic Store introduction<\/p>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/dynamic-store#class\" class=\"button-contrast-light\">The Store class<\/a>\r <a href=\"\/docs\/dynamic-store#dynamic\" class=\"button-contrast-light\">The Dynamic class<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"class\">The Neoan\\Store class<\/h2>\r <p>\r The dynamic store is a simple key-value storage meant to be written throughout the procedural execution while being writable and readable until rendering or responding.\r This is useful for default variable values when actual value can only be determined at a later point in time.\r <\/p>\r <h3>Static methods<\/h3>\r <div class=\"grid grid-cols-3 gap-3 w-full overflow-x-auto overflow-x-auto\">\r <div class=\"border-b-2 border-primary font-lg\">Method<\/div>\r <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div>\r <p>Store::dynamic(string $variableName)<\/p>\r <p class=\"span-x-2\">Returns an instance of \"Dynamic\"<\/p>\r <p>Store::write(string $variable, mixed $value)<\/p>\r <p class=\"span-x-2\">Writes to a store variable.<\/p>\r <p>Store::readValue(string $variableName)<\/p>\r <p class=\"span-x-2\">Retrieves the current value of a store variable<\/p>\r <p>Store::getInstance()<\/p>\r <p class=\"span-x-2\">Returns the instance of \"Store\"<\/p>\r <\/div>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"dynamic\">The Dynamic class<\/h2>\r <p>\r The dynamic instance for a store variable allows us to break out of certain race conditions.\r This is best explained with how this documentation uses it: In our layout template, the HTML contains a title tag.\r However, we might not know the actual title of the page before executing all routable classes. Rather than having to worry about\r passing on and handling a variable, we can use a dynamic value and - if applicable - set its value whenever needed.\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ...\r $setup = new Setup();\r $setup->setPublicPath($root . '\/public')\r ->setSkeletonHTML('configuration\/views\/layout.html')\r ->setSkeletonVariables(['title' => Store::dynamic('title')])\r ...\r <\/code><\/pre>\r <pre class=\"normalize-code\"><code class=\"language-html\" data-class=\"strip-html\" data-id=\"layout\">\r <\/code><\/pre>\r <p>In this example we prepare for the variable \"title\" to exist at the time of rendering, although it has yet to be set (\/written to).<\/p>\r <blockquote>\r Tip: In many cases a default value is useful in order to ensure availability. Use \"Store::write\" early or even before in your execution logic (maybe in your setup).\r <\/blockquote>\r <p>\r We can now decide to assign a value in any middleware or routable along the chain. For our example, we can add our custom page title in our route(s):\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r #[Web('\/docs\/dynamic-store', '\/docs\/dynamicstore.html')]\r class DynamicStore implements Routable\r {\r public function __invoke(): array\r {\r Store::write('title', 'DynamicStore');\r return ['renderVariable' => 'exampleValue'];\r }\r }\r <\/code><\/pre>\r <\/div>\r <script type=\"text\/html\" id=\"layout\">\r &lt;!-- layout.html --&gt;\r &lt;!DOCTYPE html&gt;\r &lt;html lang=\"en\"&gt;\r &lt;head&gt;\r &lt;meta charset=\"UTF-8\"&gt;\r &lt;title&gt;&#123;&#123;title}}&lt;\/title&gt;\r &lt;\/head&gt;\r ...\r <\/script>\r\n<\/section>\r\n","headlines":[{"id":"class","title":"The Neoan\\Store class","context":"The dynamic store is a simple key-value storage meant to be written throughout the procedural execution while being writable and readable until rendering or responding.\r This is useful for default variable values when actual value can only be determined at a later point in time.\r \r Static methods"},{"id":"dynamic","title":"The Dynamic class","context":"The dynamic instance for a store variable allows us to break out of certain race conditions.\r This is best explained with how this documentation uses it: In our layout template, the HTML contains a title tag.\r However, we might not know the actual title of the page before executing all routable classes. Rather than having to worry about\r passing on and handling a variable, we can use a dyna"}],"url":"\/docs\/dynamic-store"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/events.html","topic":"events","description":"Events are commonly used to react to code executed later in the process.\r This is useful both to listen to internal processes, as well as custom defined events.\r \r \r The Event class\r Generic events\r Basic examples\r Listening to classes\r \r \r The Event class\r \r Event is on of the classes used stat...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r\n<!--    url: \/docs\/events -->\r <h1>Events<\/h1>\r <p>\r Events are commonly used to react to code executed later in the process.\r This is useful both to listen to internal processes, as well as custom defined events.\r <\/p>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/events#class\" class=\"button-contrast-light\">The Event class<\/a>\r <a href=\"\/docs\/events#generic\" class=\"button-contrast-light\">Generic events<\/a>\r <a href=\"\/docs\/events#examples\" class=\"button-contrast-light\">Basic examples<\/a>\r <a href=\"\/docs\/events#listening-classes\" class=\"button-contrast-light\">Listening to classes<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"class\">The Event class<\/h2>\r <p>\r Event is on of the classes used statically.\r <\/p>\r <h3>Main methods<\/h3>\r <div class=\"grid grid-cols-3 gap-3 w-full overflow-x-auto overflow-x-auto\">\r <div class=\"border-b-2 border-primary font-lg\">Method<\/div>\r <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div>\r <p>Event::on(string $eventName, callable $callable)<\/p>\r <p class=\"span-x-2\">Executes a callable when the defined event is dispatched<\/p>\r <p>Event::dispatch(string $eventName, mixed $payload)<\/p>\r <p class=\"span-x-2\">Dispatches an event and triggers registered listeners<\/p>\r <p>Event::onAny(callable $callable)<\/p>\r <p class=\"span-x-2\">Executes a callable whenever an event is dispatched<\/p>\r <p>Event::subscribeToClass(string $className, callable $callable)<\/p>\r <p class=\"span-x-2\">Fires whenever the notify event is fired from internal classes (Routable & Model updates) or custom classes made available through:<\/p>\r <p>Event::makeListenable(string $className)<\/p>\r <p class=\"span-x-2\">Exposes the notifier in a custom class<\/p>\r <\/div>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"generic\">Generic events<\/h2>\r <p>\r Lenkrad dispatches own events that are used internally, but can be reacted on whenever convenient.\r <\/p>\r <h3>Generic events<\/h3>\r <div class=\"grid grid-cols-3 gap-3 w-full overflow-x-auto overflow-x-auto\">\r <div class=\"border-b-2 border-primary font-lg\">Event<\/div>\r <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div>\r <p>DATABASE_ADAPTER_CONNECTED<\/p>\r <p class=\"span-x-2\">Fires when a database adapter has been loaded into the app<\/p>\r <p>BEFORE_DATABASE_TRANSACTION<\/p>\r <p class=\"span-x-2\">Fires whenever a database transaction is about to happen<\/p>\r <p>AFTER_DATABASE_TRANSACTION<\/p>\r <p class=\"span-x-2\">Fires whenever a database transaction happened<\/p>\r <p>BEFORE_RENDERING<\/p>\r <p class=\"span-x-2\">Fires before the rendering process begins<\/p>\r <p>REQUEST_HANDLER_INITIALIZED<\/p>\r <p class=\"span-x-2\">Fires when the request handler is initialized<\/p>\r <p>REQUEST_HEADERS_SET<\/p>\r <p class=\"span-x-2\">Fires when request headers are set<\/p>\r <p>REQUEST_INPUT_PARSED<\/p>\r <p class=\"span-x-2\">Fires when input has been parsed into \"Input\"<\/p>\r <p>ROUTE_HANDLER_INITIALIZED<\/p>\r <p class=\"span-x-2\">Fires when the route handler is initialized<\/p>\r <p>ROUTE_REGISTERED<\/p>\r <p class=\"span-x-2\">Fires when a route is registered<\/p>\r <p>RESPONSE_HANDLER_SET<\/p>\r <p class=\"span-x-2\">Fires when the response handler is set<\/p>\r <p>BEFORE_RESPONSE<\/p>\r <p class=\"span-x-2\">Fires before result is handed over to the response handler<\/p>\r <p>ROUTE_INJECTION<\/p>\r <p class=\"span-x-2\">Fires when data is injected into a route<\/p>\r <p>BEFORE_ROUTABLE_EXECUTION<\/p>\r <p class=\"span-x-2\">Fires before a routable class is executed<\/p>\r <\/div>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"examples\">Basic examples<\/h2>\r <h3>Listening to a generic event<\/h3>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ...\r use Neoan\\Event\\Event;\r use Neoan\\Enums\\GenericEvent;\r Event::on(GenericEvent::BEFORE_RESPONSE, function($event){\r if($event['handler'] === 'html'){\r header('X-Custom-header: web-app');\r }\r });\r <\/code><\/pre>\r <h3>Listening to a custom event<\/h3>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ...\r use Neoan\\Event\\Event;\r $logFile = dirname(__DIR__,2) . '\/log.txt';\r Event::on('log', function($event){\r $data = [\r 'time' => time(),\r 'event' => $event\r ];\r file_put_contents($logFile, json_encode($data), FILE_APPEND);\r });\r <\/code><\/pre>\r <h3>Dispatching a custom event<\/h3>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ...\r use Neoan\\Event\\Event;\r ...\r $event = [\r 'msg' => 'Email sent to: ' . $newUser->email\r ];\r Event::dispatch('log', $event);\r <\/code><\/pre>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"listening-classes\">Listening to classes<\/h2>\r <p>\r You can subscribe to particular classes an react to whenever they use their notifier.\r This can be useful when listing for a particular model, for example.\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ...\r use Neoan\\Event\\Event;\r use App\\Models\\UserModel;\r ...\r Event::subscribeToClass(UserModel::class, function($eventName, $class, $arguments){\r \/\/ do something\r });\r <\/code><\/pre>\r <p>\r You can also make any class listenable like this\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ?php\r use Neoan\\Event\\Event;\r use Neoan\\Event\\Listenable;\r use Neoan\\Event\\EventNotification;\r class AnyClass implements Listenable\r {\r private EventNotification $notifier;\r function __construct()\r {\r $this->notifier = Event::makeListenable($this);\r }\r function doSomething(string $value)\r {\r ...\r $this->notifier->inform($value);\r }\r }\r <\/code><\/pre>\r <\/div>\r\n<\/section>","headlines":[{"id":"class","title":"The Event class","context":"Event is on of the classes used statically.\r \r Main methods\r \r Method\r Description\r Event::on(string $eventName, callable $callable)\r Executes a callable when the"},{"id":"generic","title":"Generic events","context":"Lenkrad dispatches own events that are used internally, but can be reacted on whenever convenient.\r \r Generic events\r \r Event\r Description\r DATABASE_ADAPTER_CONNECTED"},{"id":"examples","title":"Basic examples","context":"Listening to a generic event\r \r ...\r use Neoan\\Event\\Event;\r use Neoan\\Enums\\GenericEvent;\r Event::on(GenericEvent::BEFORE_RESPONSE, function($event){\r if($event['handler'] === 'html'){\r header('X-Custom-header: web-app');\r }\r });\r \r Listening to a custom event"},{"id":"listening-classes","title":"Listening to classes","context":"You can subscribe to particular classes an react to whenever they use their notifier.\r This can be useful when listing for a particular model, for example.\r \r \r ...\r use Neoan\\Event\\Event;\r use App\\Models\\UserModel;\r ...\r Event::subscribeToClass(UserModel::class, function($eventName, $class, $arguments){\r \/\/ do something\r });"}],"url":"\/docs\/events"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/home.html","topic":"getting started","description":"In order to get you set up, you can either create your own setup from scratch (see Quick Start) or use one of the starter projects.  Either way, in order to follow this documentation a working LENKRAD application is necessary.      Quick Start      Starter Projects    Basics  LENKRAD is an all-pur...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <h1>Getting Started<\/h1> <p> In order to get you set up, you can either create your own setup from scratch (see <a href=\"\/quick-start\">Quick Start<\/a>) or use one of the <a href=\"\/starter-projects\">starter projects<\/a>. <br> Either way, in order to follow this documentation a working LENKRAD application is necessary. <\/p> <div class=\"grid grid-cols-2 gap-3 w-3\/5 m-x-auto\"> <div> <a href=\"\/quick-start\" class=\"relative block\"> <svg class=\"\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M17.657 18.657A8 8 0 016.343 7.343S7 9 9 10c0-2 .5-5 2.986-7C14 5 16.09 5.777 17.656 7.343A7.975 7.975 0 0120 13a7.975 7.975 0 01-2.343 5.657z\"><\/path><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9.879 16.121A3 3 0 1012.015 11L11 14H9c0 .768.293 1.536.879 2.121z\"><\/path><\/svg> <span class=\"bg-neutral absolute text-center left-0 bottom-0 w-full border-l-2 border-primary\">Quick Start<\/span> <\/a> <\/div> <div> <a href=\"\/starter-projects\" class=\"relative block\"> <svg fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\"><path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M13 10V3L4 14h7v7l9-11h-7z\"><\/path><\/svg> <span class=\"bg-neutral absolute text-center left-0 bottom-0 w-full border-l-2 border-accent\">Starter Projects<\/span> <\/a> <\/div> <\/div> <h2>Basics<\/h2> <p> LENKRAD is an all-purpose framework, but we are going to concentrate on two of the most common use-cases in web development: <\/p> <ul> <li>API - a backend for your powerful frontend, app or embedded software<\/li> <li>SSR - A all-in-one monolith to generate anything from your personal site to your SAAS business<\/li> <\/ul> <h2>Cross-referencing<\/h2> <p> LENKRAD is very flexible, injectable and customizable and consists of loosely coupled components. This documentation is therefore prone to \"but in my case it's different\"-situations. Our starter projects are designed to mitigate this issue, but this does not change the fact that one page of this documentation will likely lead you to 3 others. The bad news is: there's a reason we call it a <em>core<\/em> instead of a framework. The good news is: the learning curve is not even half as bad as one might initially think. <\/p> <h2>Get in touch<\/h2> <p> This documentation is a living document inspired by your feedback & questions. If you want to engage, please visit <a href=\"https:\/\/github.com\/sroehrl\/php-lenkrad-docs\/issues\">Github<\/a> (While you are there, don't forget to star) <\/p> <h2>Terminology<\/h2> <p> Sometimes it's necessary to refer to concepts that aren't clear due to conflicting definitions. To avoid confusion as far as possible, we added a glossary: <\/p> <div class=\"grid grid-cols-3 gap-3\"> <div class=\"border-b-2 border-primary font-lg\">Term<\/div> <div class=\"border-b-2 border-primary font-lg\">Description<\/div> <div class=\"border-b-2 border-primary font-lg\">Notes<\/div> <h3 id=\"attributes\">Attributes<\/h3> <p> In PHP, attributes is the name given to what most other languages refer to as <em>annotation<\/em>. The feature was introduced in PHP8 LENKRAD makes heavy use of its capabilities. <\/p> <p> <\/p> <h3 id=\"web-route\">Web-route<\/h3> <p>Refers to a Route answering with markup (HTML) using a template.<\/p> <p>This very page is a web-route.<\/p> <h3 id=\"api-route\">API-route<\/h3> <p>Similarly, an API-route is intended to be machine read.<\/p> <p>LENKRAD's default response-handler defaults to JSON-format.<\/p> <h3 id=\"templating\">Templating<\/h3> <p>Templates are markup-shells (HTML) the rendering process uses to apply data to. <\/p> <p>Demo: click <a href=\"docs?say=HELLO\">here<\/a>, watch the url and then see this: {{say}}<\/p> <h3 id=\"middleware\">Middleware<\/h3> <p> In LENKRAD, this concept can be simplified down to code that is executed before your controller logic applies. Middleware can be chained to facilitate guards (e.g. authentication) or to ensure availability of certain data, permissions etc. <\/p> <p> Middleware normalization is very little opinionated in LENKRAD as execution chains are loosely coupled. <\/p> <h3 id=\"di\">Dependency Injection<\/h3> <p>The concept refers to injecting dependencies rather than coupling them. This is were Interfaces shine.<\/p> <p>LENKRAD has an auto-wire dependency injection. This allows you to inject concrete dependencies automatically as needed.<\/p> <\/div>\n<\/section>","headlines":[{"id":"attributes","title":"Attributes","context":"In PHP, attributes is the name given to what most other languages refer to as annotation. The feature was introduced in PHP8 LENKRAD makes heavy use of its capabilities.    Web-route Refers to a Route answering with markup (HTML) using a template. This very page is a web-route. API-route Similarly, an API-rou"},{"id":"web-route","title":"Web-route","context":"Refers to a Route answering with markup (HTML) using a template. This very page is a web-route. API-route Similarly, an API-route is intended to be machine read. LENKRAD's default response-handler defaults to JSON-format. Templating Templates are markup-shells (HTML) the rendering process uses to apply data to."},{"id":"api-route","title":"API-route","context":"Similarly, an API-route is intended to be machine read. LENKRAD's default response-handler defaults to JSON-format. Templating Templates are markup-shells (HTML) the rendering process uses to apply data to.  Demo: click here, watch the url and then see this: {{say}} Middleware  In LENKRAD"},{"id":"templating","title":"Templating","context":"Templates are markup-shells (HTML) the rendering process uses to apply data to.  Demo: click here, watch the url and then see this: {{say}} Middleware  In LENKRAD, this concept can be simplified down to code that is executed before your controller logic applies. Middleware can be chained to facilitate guards (e.g. authenticati"},{"id":"middleware","title":"Middleware","context":"In LENKRAD, this concept can be simplified down to code that is executed before your controller logic applies. Middleware can be chained to facilitate guards (e.g. authentication) or to ensure availability of certain data, permissions etc.   Middleware normalization is very little opinionated in LENKRAD as execution chains are loosely coupled.  Dependency Injection"},{"id":"di","title":"Dependency Injection","context":"The concept refers to injecting dependencies rather than coupling them. This is were Interfaces shine. LENKRAD has an auto-wire dependency injection. This allows you to inject concrete dependencies automatically as needed."}],"url":"\/docs"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/in-development.html","topic":"\n    ","description":"working on it     This page or section is currently being worked on or under review. Please check back soon......","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <h1 class=\"grid grid-cols-3\" > <svg style=\"max-width: 100px\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-6 h-6\"> <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6.75 7.5l3 2.25-3 2.25m4.5 0h3m-9 8.25h13.5A2.25 2.25 0 0021 18V6a2.25 2.25 0 00-2.25-2.25H5.25A2.25 2.25 0 003 6v12a2.25 2.25 0 002.25 2.25z\" \/> <\/svg> <span class=\"span-x-2 place-center-auto\"> We're working on it <\/span> <\/h1> <div class=\"bg-warning p-5 border-danger border-l-4 relative\"> <p class=\"font-lg\"> This page or section is currently being worked on or under review. Please check back soon... <\/p> <\/div> <\/section>","headlines":[],"url":"\/docs"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/middleware.html","topic":"middleware","description":"Middleware chaining is an important concept when working with LENKRAD.\r We are going to focus on routable classes here.\r \r \r Concept\r Loading middleware\r Declaring middleware\r Passing on values\r \r \r Concept\r \r Middleware classes in routes need to implement \\Neoan\\Routing\\Interfaces\\Routable and...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r\n<!--    url: \/docs\/middleware -->\r <h1>Middleware<\/h1>\r <p>\r Middleware chaining is an important concept when working with LENKRAD.\r We are going to focus on routable classes here.\r <\/p>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/middleware#concept\" class=\"button-contrast-light\">Concept<\/a>\r <a href=\"\/docs\/middleware#loading\" class=\"button-contrast-light\">Loading middleware<\/a>\r <a href=\"\/docs\/middleware#declaring\" class=\"button-contrast-light\">Declaring middleware<\/a>\r <a href=\"\/docs\/passing-on\" class=\"button-contrast-light\">Passing on values<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"concept\">Concept<\/h2>\r <p>\r Middleware classes in routes need to implement <em>\\Neoan\\Routing\\Interfaces\\Routable<\/em> and be invokable\r (using an __invoke-method). Middleware can be chained and is commonly used for route-guards or retrieval of repetitive information (e.g. current user).\r The structure allows for route controllers to double as middleware and reuse their functionality.\r <\/p>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"loading\">Loading middleware<\/h2>\r <p>\r When using Attributes\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ?php\r namespace App\\Docs;\r use App\\Middleware\\RequiresAuth;\r use App\\Middleware\\RequiresWritePrivilege;\r use Neoan\\Provider\\Injections;\r use Neoan\\Routing\\Interfaces\\Routable;\r use Neoan\\Routing\\Attributes\\Web;\r \/\/ Attribute routing directly allows for middleware chaining.\r \/\/ Here, both \"RequiresAuth\" and \"RequiresWritePrivilege\" is executed\r \/\/ before resolving the route \/docs\/middleware\r #[\r Web(\r '\/docs\/middleware',\r '\/docs\/middleware.html',\r RequiresAuth::class,\r RequiresWritePrivilege::class\r )\r ]\r class Middleware implements Routable\r {\r public function __invoke(Injections $injections): array\r {\r \/\/ see \"Declaring middleware\"\r return ['user' => $injections->get('user', null)];\r }\r }\r <\/code><\/pre>\r <p>\r When using Route declarations\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ?php\r namespace App;\r use Neoan\\Routing\\Route;\r use App\\Middleware\\RequiresAuth;\r use App\\Middleware\\RequiresWritePrivilege;\r use App\\Person\\UpdatePerson;\r \/\/ When chaining using the route class, the classes are invoked in order,\r \/\/ effectively making the last class your controller\r Route::put('\/person\/:id', RequiresAuth::class, RequiresWritePrivilege::class, UpdatePerson::class);\r <\/code><\/pre>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"declaring\">Declaring middleware<\/h2>\r <p>\r The structure of middleware does not differ from a controller, making it possible to use the cli to create\r middleware classes just as one would generate a controller.\r <\/p>\r <p>Example<\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ?php\r namespace App\\Middleware;\r use Auth;\r use Neoan\\Routing\\Interfaces\\Routable;\r use Neoan\\Errors\\Unauthorized;\r use Neoan\\Provider\\Injections;\r \/\/ This middleware stops execution and throws an unauthorized error if user is not logged in\r class RequiresAuth implements Routable\r {\r \/\/ using \"auth\" (custom) and \"injections\" (included in core) from DI-container\r public function __invoke(Auth $auth, Injections $injections): void\r {\r if(!$user = $auth->get()) {\r new Unauthorized();\r }\r $injections->set('user', $user);\r }\r }\r <\/code><\/pre>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"passing-on\">Passing on values<\/h2>\r <p>\r As seen in the example above, we are able to hook into the injection provider to write values to the following controllers in the chain.\r However, you might consider choosing to adjust your middleware to be used by the auto-wiring mechanism of the DI-container.\r To do so, make sure to return the running instance (see <a href=\"\/docs\/dependency-injection\">DI-container<\/a>).\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ?php\r namespace App\\Middleware;\r use Auth;\r use Neoan\\Routing\\Interfaces\\Routable;\r use Neoan\\Errors\\Unauthorized;\r class RequiresAuth implements Routable\r {\r \/\/ let's add a user array\r public array $user;\r \/\/ we can remove the injections and return ourselves\r public function __invoke(Auth $auth): static\r {\r \/\/ let's use the local variable \"user\"\r if(!$this->user = $auth->get()) {\r new Unauthorized();\r }\r \/\/ finally, return the instance\r return $this;\r }\r }\r <\/code><\/pre>\r <\/div>\r\n<\/section>","headlines":[{"id":"concept","title":"Concept","context":"Middleware classes in routes need to implement \\Neoan\\Routing\\Interfaces\\Routable and be invokable\r (using an __invoke-method). Middleware can be chained and is commonly used for route-guards or retrieval of repetitive information (e.g. current user).\r The structure allows for route controllers to double as middleware and reuse their functionality."},{"id":"loading","title":"Loading middleware","context":"When using Attributes\r \r \r ?php\r namespace App\\Docs;\r use App\\Middleware\\RequiresAuth;\r use App\\Middleware\\RequiresWritePrivilege;\r use Neoan\\Provider\\Injections;\r use Neoan\\Routing\\Interfaces\\Routable;\r use Neoan\\Routing\\Attributes\\Web;\r \/\/ Attribute routing directly allows for middleware chaining.\r \/\/ Here, both \"RequiresAuth\" and"},{"id":"declaring","title":"Declaring middleware","context":"The structure of middleware does not differ from a controller, making it possible to use the cli to create\r middleware classes just as one would generate a controller.\r \r Example\r \r ?php\r namespace App\\Middleware;\r use Auth;\r use Neoan\\Routing\\Interfaces\\Routable;\r use Neoan\\Errors\\Unauthorized;\r use Neoan\\Provider\\Injections"},{"id":"passing-on","title":"Passing on values","context":"As seen in the example above, we are able to hook into the injection provider to write values to the following controllers in the chain.\r However, you might consider choosing to adjust your middleware to be used by the auto-wiring mechanism of the DI-container.\r To do so, make sure to return the running instance (see DI-container)."}],"url":"\/docs\/middleware"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/models.html","topic":"models","description":"Models are the heart and soul of dealing with persistent data.\r LENKRAD has a sophisticated ORM automation to deal with this common topic.\r This means that when we talk about models, we always talk about databases as well.\r \r \r The Model class\r Defining a model\r Computed values\r Hooks\r Collectio...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r\n<!--    url: \/docs\/models -->\r <h1>Models<\/h1>\r <p>\r Models are the heart and soul of dealing with persistent data.\r LENKRAD has a sophisticated ORM automation to deal with this common topic.\r This means that when we talk about models, we always talk about databases as well.\r <\/p>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/models#class\" class=\"button-contrast-light\">The Model class<\/a>\r <a href=\"\/docs\/models#define\" class=\"button-contrast-light\">Defining a model<\/a>\r <a href=\"\/docs\/models#computed\" class=\"button-contrast-light\" version=\">0.2\">Computed values<\/a>\r <a href=\"\/docs\/models#hooks\" class=\"button-contrast-light\" version=\">0.2\">Hooks<\/a>\r <a href=\"\/docs\/models#collections\" class=\"button-contrast-light\">Collections<\/a>\r <a href=\"\/docs\/models#usage\" class=\"button-contrast-light\">Using a model<\/a>\r <a href=\"\/docs\/models#pagination\" class=\"button-contrast-light\">Pagination<\/a>\r <a href=\"\/docs\/models#magic\" class=\"button-contrast-light\">Magic methods<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"class\">The Model class<\/h2>\r <p>\r LENKRAD uses one file to declare and interact with models. This includes:\r <\/p>\r <ul>\r <li>Database interactions<\/li>\r <li>Database migrations<\/li>\r <li>Object relational mapping<\/li>\r <\/ul>\r <p>A new instance of this model now has the following <em>static<\/em> methods available:<\/p>\r <div class=\"grid grid-cols-3 gap-3\">\r <div class=\"border-b-2 border-primary font-lg span-x-2\">Method<\/div>\r <div class=\"border-b-2 border-primary font-lg\">Description<\/div>\r <p class=\"span-x-2\">get(int|string $id)<\/p>\r <p>Retrieves an instance of the model by primary id.<\/p>\r <p class=\"span-x-2\">retrieve(array $condition, array $filter = [])<\/p>\r <p>Returns a <a href=\"\/docs\/models#collections\">collection<\/a><\/p>\r <p class=\"span-x-2\">retrieveOne(array $condition, array $filter = [])<\/p>\r <p>Retrieves an instance of the model based on condition and\/or filter<\/p>\r <p class=\"span-x-2\">retrieveOneOrCreate(array $condition)<\/p>\r <p>If a model with the condition exists, it's retrieved, else it's created.<\/p>\r <p class=\"span-x-2\">paginate(int $page = 1, int $pageSize = 30)<\/p>\r <p>Returns a <a href=\"\/docs\/models#pagination\">Pagination<\/a> instance<\/p>\r <p class=\"span-x-2\">declare()<\/p>\r <p>Returns the structure in a standardized format (mainly to be used for migrations & transactions)<\/p>\r <\/div>\r <p>And the following <em>initiated<\/em> methods:<\/p>\r <div class=\"grid grid-cols-3 gap-3\">\r <div class=\"border-b-2 border-primary font-lg span-x-2\">Method<\/div>\r <div class=\"border-b-2 border-primary font-lg\">Description<\/div>\r <p class=\"span-x-2\">store()<\/p>\r <p>Executes database transaction(s) to store model changes.<\/p>\r <p class=\"span-x-2\">delete(bool $hard = false)<\/p>\r <p>Soft or hard deletes the mapped entity.<\/p>\r <p class=\"span-x-2\">toArray()<\/p>\r <p>Converts the model object to an assoc array<\/p>\r <p class=\"span-x-2\">rehydrate()<\/p>\r <p>Refills (resets) the instance with database driven values<\/p>\r <p class=\"span-x-2\">getTransactionMode()<\/p>\r <p>Returns the TransactionType enum currently active (INSERT | UPDATE)<\/p>\r <p class=\"span-x-2\">setTransactionMode(TransactionType $type)<\/p>\r <p>Overrides the internal transaction mode.<\/p>\r <p class=\"span-x-2\">__call()<\/p>\r <p>See <a href=\"\/docs\/models#magic\">Magic methods<\/a><\/p>\r <\/div>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"define\">Defining a Model<\/h2>\r <p>\r In order to create a model new, you simply extend the <a href=\"\/docs\/models#class\">Model class<\/a>\r and give it the properties you need.\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r namespace App\\Models;\r use Neoan\\Model\\Model;\r use Neoan\\Model\\Attributes\\IsPrimaryKey;\r use Neoan\\Model\\Attributes\\IsUnique;\r use Neoan\\Model\\Attributes\\Transform;\r use Neoan\\Model\\Transformers\\Hash;\r class User extends Model\r {\r #[IsPrimaryKey]\r public int $id;\r #[IsUnique]\r public string $email;\r public string $userName;\r #[Transform(Hash::class)]\r public string $password;\r }\r <\/code><\/pre>\r <h3>Default & Custom Types<\/h3>\r <p>\r Depending on the database adapter you use (see <a href=\"\/quick-start\">Quick Start<\/a>),\r your PHP types will translate into a default column type. For example, the recommended MySQL adapter\r will assume a string to be <em>varchar<\/em> with the length of 255, a PHP integer to be <em>int<\/em> with a\r length\r of 11 and so on. If you want to influence this behavior, you can use attributes to do so. The generic\r attribute\r <em>Type<\/em> allows you to be very specific as well:\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ...\r use Neoan\\Model\\Transformers\\Type;\r ...\r #[Type('LONGTEXT')]\r public $post;\r ...\r <\/code><\/pre>\r <p>\r The following model attributes are shipped with LENKRAD\r <\/p>\r <div class=\"grid grid-cols-2 gap-3\">\r <div class=\"border-b-2 border-primary font-lg\">Attribute<\/div>\r <div class=\"border-b-2 border-primary font-lg\">Description<\/div>\r <p>HasMany(string $modelName, array $matchingRule = [])<\/p>\r <p>Enables automatic loading of one-to-many relationships by attaching a <a href=\"\/docs\/models#collections\">collection<\/a>\r <\/p>\r <p>Ignore<\/p>\r <p>Signifies a property that shall be ignored by database transactions.<\/p>\r <p>Initialize(mixed $setter)<\/p>\r <p>Attaches a value or instance to the model at creation. (For example a date-converter)<\/p>\r <div version=\"0.1\">\r <p>IsForeignKey(string $table, string $property, string $modelName)<\/p>\r <\/div>\r <div version=\">0.1\">\r <p>IsForeignKey(string $modelName, ?string $property)<\/p>\r <\/div>\r <p>Enhances relationship lookup performance and enables <a href=\"\/docs\/models#magic\">magic relationships<\/a>\r <\/p>\r <p>IsPrimaryKey<\/p>\r <p>REQUIRED! Indicates the index of a model for many operations.<\/p>\r <p>IsUnique<\/p>\r <p>handles UNIQUE constraints<\/p>\r <p>Transform(string $transformerClass)<\/p>\r <p>\r Generic hook for transforming values bi- or one-directional (own transformers must implement\r Neoan\\Model\\Interfaces\\Transformation).\r LENKRAD ships with the transformers <em>Hash<\/em> and <em>CurrentTimeIn<\/em> out of the box.\r <\/p>\r <p>Type(string $type, int $length = null, string $default = null)<\/p>\r <p>As discussed, enables custom column-type-matching<\/p>\r <\/div>\r <h3>Constants<\/h3>\r <p>\r To escape further default behavior, constants are used. With new Projects, there shouldn't\r be any necessity for that.\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r const tableName = 'user_table';\r <\/code><\/pre>\r <div class=\"grid grid-cols-2 gap-3\">\r <div class=\"border-b-2 border-primary font-lg\">Constant<\/div>\r <div class=\"border-b-2 border-primary font-lg\">Description<\/div>\r <p>tableName<\/p>\r <p>Overrides the usage of the class name as the table name.<\/p>\r <\/div>\r <h3>Traits<\/h3>\r <p>\r To simplify data structure, traits offer an easy way to escape duplication. LENKRAD offers the following\r model traits out of the box:\r <\/p>\r <div class=\"grid grid-cols-3 gap-3\">\r <div class=\"border-b-2 border-primary font-lg\">Trait<\/div>\r <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div>\r <p>Setter<\/p>\r <p class=\"span-x-2\">\r Enables the model to deal with private and\/or readonly properties.\r It also exposes the method <em>set(string $propertyName, mixed $value)<\/em>\r to the model.\r <\/p>\r <p>TimeStamps<\/p>\r <p class=\"span-x-2\">\r Shorthand for the common fields <strong>createdAt, updatedAt, and deletedAt<\/strong>.\r In addition to allowing for soft-deletion, this trait handles time format transformations.\r <\/p>\r <\/div>\r <h3>Full Example<\/h3>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r namespace App\\Models;\r use Neoan\\Model\\Model;\r use Neoan\\Model\\Attributes\\IsPrimaryKey;\r use Neoan\\Model\\Attributes\\IsUnique;\r use Neoan\\Model\\Attributes\\Transform;\r use Neoan\\Model\\Transformers\\Hash;\r use Neoan\\Model\\Traits\\Setter;\r use Neoan\\Model\\Traits\\TimeStamps;\r class User extends Model\r {\r #[IsPrimaryKey]\r public readonly int $id;\r #[IsUnique]\r public string $email;\r public string $userName;\r #[Transform(Hash::class)]\r public string $password;\r use Setter;\r use TimeStamps;\r }\r <\/code><\/pre>\r <h3>Migration<\/h3>\r <p>\r Creating and updating tables according to your model must be done whenever changes to your\r model declaration have been conducted. The <a href=\"\/docs\/cli-basics\">cli tool<\/a> makes this possible using\r one command.\r <\/p>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\" version=\">0.2\">\r <h2 id=\"computed\">Computed values<\/h2>\r <p>\r A model is often more than a mapping to persistent data. Sometimes we want to derive information from that data and have our controllers consume it\r with more ease. Computed values are meant to help with this.\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r namespace App\\Models;\r use Neoan\\Model\\Model;\r use Neoan\\Model\\Attributes\\IsPrimaryKey;\r use Neoan\\Model\\Attributes\\IsForeignKey;\r use Neoan\\Model\\Attributes\\Computed;\r class Person extends Model\r {\r #[IsPrimaryKey]\r public int $id;\r #[IsForeignKey(User::class)]\r public int $userId;\r public string $firstName;\r public string $lastName;\r #[Computed]\r public function fullName(): string\r {\r return ($this->firstName ?? '') . ' ' . ($this->lastName ?? 'Anonymous');\r }\r }\r <\/code><\/pre>\r <h3>Consumption<\/h3>\r <p>\r Instead of having to call the method, you can read the value as property. <br>\r Computed values are processed by data normalization and are therefore exposed in controller,\r templating (rendering), or JSON response:\r <\/p>\r <h3>HTML<\/h3>\r <pre class=\"normalize-code\"><code class=\"language-html\" data-class=\"strip-html\" data-id=\"fullName\"><\/code><\/pre>\r <h3>JSON API response<\/h3>\r <pre class=\"normalize-code\"><code class=\"language-json\">\r {\r \"id\": 1,\r \"firstName\": \"Adam\",\r \"lastName\": \"Smith\",\r \"fullName\": \"Adam Smith\"\r }\r <\/code><\/pre>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\" version=\">0.2\">\r <h2 id=\"hooks\">Hooks<\/h2>\r <p>\r Interacting with models fires <a href=\"\/docs\/events\">Events<\/a> and every model is <a href=\"\/docs\/events#listening-classes\">listenable<\/a>.\r In some cases relying on \"external\" logic to facilitate things that should run \"whenever I save\" might better be addressed directly.\r To do just that, you can choose to overwrite the following model-methods\r <\/p>\r <div class=\"grid grid-cols-2 gap-3\">\r <div class=\"border-b-2 border-primary font-lg\">Method<\/div>\r <div class=\"border-b-2 border-primary font-lg\">Description<\/div>\r <p>afterStore()<\/p>\r <p>Is executed after database transaction & rehydration<\/p>\r <p>afterDeletion()<\/p>\r <p>Is executed after database transaction & before destruction<\/p>\r <\/div>\r <p>\r Remembering our examples above, let's pretend our movies have a rating based on the average of the\r model <em>Rating<\/em>, representing a single vote by a user.\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r namespace App\\Models;\r use Neoan\\Model\\Model;\r use Neoan\\Model\\Attributes\\IsPrimaryKey;\r use Neoan\\Model\\Attributes\\IsForeignKey;\r class Rating extends Model\r {\r #[IsPrimaryKey]\r public int $id;\r #[IsForeignKey(Movie::class)]\r public int $movieId;\r public int $rating;\r public function afterStore(): void\r {\r \/\/ if you want to fire respective events BEFORE your logic happens, place\r \/\/ this at the top. If you want to fire event AFTER your logic, at the end.\r \/\/ If you want to suppress events, don't call the parent method at all.\r \/\/ parent::afterStore();\r $newAverageRating = Calculations::methodReturningAverageRatingByMovieId($this->movieId);\r $movie = $this->movie();\r $movie->rated = $newAverageRating;\r $movie->store();\r }\r }\r <\/code><\/pre>\r <blockquote>\r Be mindful of the execution chain and possible infinite loops when dealing with hooks. In this example,\r it's easy to imagine what would happen if the model <em>Movie<\/em> would also use this hook and so on.\r <\/blockquote>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"collections\">Collections<\/h2>\r <p>\r A collection instance is useful when dealing with multiple different instances of a given model.\r This is commonly the case when retrieving multiple entries. A collection is iterable and offers useful\r methods:\r <\/p>\r <div class=\"grid grid-cols-3 gap-3\">\r <div class=\"border-b-2 border-primary font-lg\">Method<\/div>\r <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div>\r <p>each(fn)<\/p>\r <p class=\"span-x-2\">\r Expects a closure or invokable while iterating over the instances.\r <\/p>\r <p>add(Model $instance)<\/p>\r <p class=\"span-x-2\">\r Manually adds an instance to the collection.\r <\/p>\r <p>toArray<\/p>\r <p class=\"span-x-2\">\r Returns all entries as one array.\r <\/p>\r <p>store<\/p>\r <p class=\"span-x-2\">\r Runs store commands for all instances contained in the collection (beware of performance!).\r <\/p>\r <p>count<\/p>\r <p class=\"span-x-2\">\r Returns an integer with the number of held model instances.\r <\/p>\r <\/div>\r <h3>Examples<\/h3>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r \/\/ this is an example, please don't take this seriously:\r \/\/ return all users as collection\r $userCollection = User::retrieve();\r \/\/ a collection is iterable:\r foreach($userCollection as $userInstance){\r ...\r }\r \/\/ but you likely want to make use of typing\r $userCollection->each(function(User $user){\r if(str_ends_with($user->email, '@protonmail.com')) {\r $this->sendSecureEmail($user);\r }\r });\r \/\/ how many users?\r $registeredUsers = $userCollection->count();\r \/\/ add a new user\r if($registeredUsers &lt; $this->marketingGoal) {\r for($i = 0; $i &lt; $this->marketingGoal - $registeredUsers; $i++) {\r $bot = new User([\r 'email' => \"myspam+{$i}@gmail.com\",\r 'userName' => 'bot-' . $i,\r 'password' => 'you-wish-800-' . $i\r ]);\r $userCollection->add($bot);\r }\r }\r \/\/ since we got ALL users, this could take a while...\r $userCollection->store();\r <\/code><\/pre>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"usage\">Using a model<\/h2>\r <h3>Retrieval<\/h3>\r <h4 class=\"font-md\">Conditions<\/h4>\r <p>\r Let's begin by exploring how conditions work.\r Conditions are passed into a model as assoc arrays\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r $condition = [\r 'email' => 'adam@email.com'\r ];\r $user = User::retrieveOne($condition);\r <\/code><\/pre>\r <p>\r With the MySQL adapter, this roughly translates to <br>\r <code>SELECT * FROM user WHERE email = \"adam@email.com\"<\/code>.\r Roughly, as in reality queries are optimized and executed as prepared statements.\r The following examples should help you to read & write conditions:\r <\/p>\r <div class=\"grid grid-cols-3 gap-3\">\r <div class=\"border-b-2 border-primary font-lg\">Array<\/div>\r <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div>\r <p>['email' => '%@email.com']<\/p>\r <p class=\"span-x-2\">Retrieve where email ends with \"@email\"<\/p>\r <p>['id' => '>100']<\/p>\r <p class=\"span-x-2\">Retrieve where id is greater than 100<\/p>\r <p>['userName' => '!adam']<\/p>\r <p class=\"span-x-2\">Retrieve where userName is not \"adam\"<\/p>\r <p>['updatedAt' => '!']<\/p>\r <p class=\"span-x-2\">Retrieve where updatedAt is not NULL (aka WHERE the record was updated at least\r once)<\/p>\r <p>['deletedAt' => null] or simply ['^deletedAt']<\/p>\r <p class=\"span-x-2\">Retrieve where deletedAt is NULL (aka undeleted entries)<\/p>\r <\/div>\r <p>\r Conditions are chained as <em>AND<\/em>, so <br>\r <code>['email' => '%@email.com', 'userName' => '!adam']<\/code> <br>\r retrieves records that meet both criteria.\r <\/p>\r <h4 class=\"font-md\">Filters<\/h4>\r <p>\r Both shipped adapters currently only provide two filters:\r <\/p>\r <div class=\"grid grid-cols-2 gap-3\">\r <div class=\"border-b-2 border-primary font-lg\">Filter<\/div>\r <div class=\"border-b-2 border-primary font-lg\">Description<\/div>\r <p>orderBy => [string $property, string $ascOrDesc]<\/p>\r <p>Influences the sorting order of results<\/p>\r <p>limit => [int $offset, int $rowCount]<\/p>\r <p>Paginates results<\/p>\r <\/div>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r $filter = [\r 'orderBy' => ['userName', 'desc'],\r 'limit' => [0,10]\r ];\r $user = User::retrieve([], $filter);\r <\/code><\/pre>\r <p>\r This would return 10 entries sorted by userName in reverse alphabetical order.\r <\/p>\r <blockquote>\r Note: If you are worried about limited complexity, rest assured that\r direct usage of the Database class can handle any potential bottleneck.\r <\/blockquote>\r <h4 class=\"font-md\">Security<\/h4>\r <p>\r Conditions are matched against the structure and type of a given model and transactions are executed as\r prepared statements.\r This annihilates user-input concerns.\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r \/\/ yes, this is save to do\r $postedInput = Request::getInputs();\r $user = User::retrieveOne($postedInput);\r <\/code><\/pre>\r <h3>Create<\/h3>\r <p>\r Creating a new model entry is as straight forward as it can be:\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r \/\/ as empty instance\r $user = new User();\r \/\/ write\r $user->userName = 'Adam'; \/\/ if type is correct, will set\r \/\/ or directly with values passed as array\r $user = new User(['userName' => 'Adam']);\r \/\/ read\r echo $user->userName; \/\/ \"Adam\"\r \/\/ write\r $user->userName = 'Ben'; \/\/ overrides old value\r try{\r $user->store();\r } catch(\\Exception $e) {\r \/\/ ups... some properties are neither nullable nor have a default value\r \/\/ so we have to set email & password\r }\r $user->password = '123123';\r $user->email = 'ben@email.com';\r \/\/ if a setter is used you can also do:\r $user->set('password', '123123')\r ->set('email', 'ben@email.com');\r $user->store();\r \/\/ after database transaction, we have an id (or other primary key)!\r $userId = $user->id;\r <\/code><\/pre>\r <h3>Update<\/h3>\r <p>\r Updating an entry is no different from creation.\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r $user = User::retrieveOne(['email' => 'ben@email.com']);\r \/\/ rename\r $user->userName = 'Benjamin';\r \/\/ save changes to db\r $user->store();\r <\/code><\/pre>\r <h3>Collection properties<\/h3>\r <p>\r If you looked at the attribute-section of <a href=\"\/docs\/models#class\">the model class<\/a>,\r you might have noticed the <em>HasMany<\/em>-attribute. In a real world scenario, one might have two models:\r <\/p>\r <p>Movie model<\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r namespace App\\Models;\r use Neoan\\Model\\Model;\r use Neoan\\Model\\Collection;\r use Neoan\\Model\\Attributes\\IsPrimaryKey;\r use Neoan\\Model\\Attributes\\HasMany;\r use Neoan\\Model\\Traits\\TimeStamps;\r class Movie extends Model\r {\r #[IsPrimaryKey]\r public int $id;\r public string $name;\r #[HasMany(Rating::class)]\r public Collection $ratings;\r use TimeStamps;\r }\r <\/code><\/pre>\r <p>Rating model<\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r namespace App\\Models;\r use Neoan\\Model\\Model;\r use Neoan\\Model\\Collection;\r use Neoan\\Model\\Attributes\\IsPrimaryKey;\r use Neoan\\Model\\Attributes\\IsForeignKey;\r use Neoan\\Model\\Traits\\TimeStamps;\r use App\\Models\\Movie;\r class Rating extends Model\r {\r #[IsPrimaryKey]\r public int $id;\r <span><span version=\"0.1\">#[IsForeignKey('movie', 'id')]<\/span><\/span>\r <span><span version=\">0.1\">#[IsForeignKey(Movie::class)]<\/span><\/span>\r public int $movieId;\r public int $rating;\r use TimeStamps;\r }\r <\/code><\/pre>\r <p>\r The result when retrieving movies now has ratings automatically attached.\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r $movie = Movie::get(1);\r \/\/ the property ratings is already a filled collection\r $numberOfRatings = $movie->ratings->count();\r <\/code><\/pre>\r <p>\r Be aware that automatically attaching large numbers of rows can lead to performance\r issues. Since a model is just a class, you can always optimize by providing own methods:\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ...\r class Movie extends Model\r {\r ...\r public ratings(): Collection\r {\r return Rating::retrieve(['movieId' => $this->id]);\r }\r }\r <\/code><\/pre>\r <p>And then use them accordingly:<\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r $movie = Movie::get(1);\r \/\/ the property ratings is already a filled collection\r $numberOfRatings = $movie->ratings()->count();\r <\/code><\/pre>\r <p>Have a look at <a href=\"\/docs\/models#magic\">Magic methods<\/a> for how one-to-one relationships are automated for this.<\/p>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"pagination\">Pagination<\/h2>\r <p>\r Pagination is a common task when dealing with lists and\/or large numbers of expected results.\r LENKRAD simplified this process.\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r $page = 1;\r $resultsPerPage = 25;\r return User::paginate($page, $resultsPerPage)\r \/\/ you can use the regular condition array to specify\r ->where(['^deletedAt])\r \/\/ newest users first? Let's get the last ids first\r ->descending('id')\r \/\/ when you're done specifying, execute\r ->get();\r <\/code><\/pre>\r <p>\r The response of a pagination call is standardized and returns the structure:\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r [\r 'page' => 1,    \/\/ current page\r 'total' => 48,      \/\/ total hits\r 'pageSize' => 25,       \/\/ number of results per page\r 'pages' => 2,       \/\/ total number of resulting pages\r 'collection' => `{Collection}`      \/\/ result as Collection\r ]\r <\/code><\/pre>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"magic\">Magic methods<\/h2>\r <p>\r LENKRAD avoids magic methods as we believe in empowering your IDE to do its job without having to\r write comments like it's 2015. However, models DO have a __call-implementation and attributes can make use of it.\r Out of the box, the attribute <em>IsForeignKey<\/em> uses it. Let's revive our movie class and add the property \"director\"\r to see it in action:\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r namespace App\\Models;\r use Neoan\\Model\\Model;\r use Neoan\\Model\\Collection;\r use Neoan\\Model\\Attributes\\IsPrimaryKey;\r use Neoan\\Model\\Attributes\\IsForeignKey;\r use Neoan\\Model\\Attributes\\HasMany;\r use Neoan\\Model\\Traits\\TimeStamps;\r class Movie extends Model\r {\r #[IsPrimaryKey]\r public int $id;\r public string $name;\r #[HasMany(Rating::class)]\r public Collection $ratings;\r \/\/ let's pretend we have a model \"Director\"\r <span><span version=\"0.1\">#[IsForeignKey('director','id', Director::class)]<\/span><\/span>\r <span><span version=\">0.1\">#[IsForeignKey(Director::class)]<\/span><\/span>\r public int $directorId;\r use TimeStamps;\r \/\/ Bonus: let's add a static helper after noticing we tend to\r \/\/ always get movies by name, but for some reason programmatically\r \/\/ (In reality one would likely notice that this is rarely necessary)\r public static function byName( string $name): ?self\r {\r return self::retrieveOne(['name' => $name]);\r }\r }\r <\/code><\/pre>\r <p>\r In action:\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r $movie = Movie::byName('Avatar');\r \/\/ Of course we have the directorId available\r $directorId = $movie->directorId;\r \/\/ now let's get the associated director!\r if($directorId === $movie->director()->id){\r \/\/ as you have guessed, we now have the director available\r }\r <\/code><\/pre>\r <p>\r Alternatively, you can remain in the parent scope by using the \"with\"-attachment:\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r \/\/ for this to work, the foreign key for class \"Director\" must exist.\r $movie = Movie::byName('Avatar')->withDirector();\r \/\/ now director is an object in $movie\r $directorName = $movie->director->name;\r \/\/ Since the binding isn't broken, we can leverage that for collections as well\r $allMovies = Movie::find([])->each(fn(Movie $movie) => $movie->withDirector());\r <\/code><\/pre>\r <blockquote>\r As mentioned, your IDE will not suggest the availability of magic methods.\r Refer to your IDE's guide on how to add magic methods to your suggestions (usually @method)\r <\/blockquote>\r <\/div>\r <script type=\"text\/html\" id=\"fullName\">\r &lt;div class=\"bg-warning\"&gt;\r &#123;&#123;fullName}}\r &lt;\/div&gt;\r <\/script>\r\n<\/section>","headlines":[{"id":"class","title":"The Model class","context":"LENKRAD uses one file to declare and interact with models. This includes:\r \r \r Database interactions\r Database migrations\r Object relational mapping\r \r A new instance of this model now has the following static methods available:\r \r Method"},{"id":"define","title":"Defining a Model","context":"In order to create a model new, you simply extend the Model class\r and give it the properties you need.\r \r \r namespace App\\Models;\r use Neoan\\Model\\Model;\r use Neoan\\Model\\Attributes\\IsPrimaryKey;\r use Neoan\\Model\\Attributes\\IsUnique;\r use Neoan\\Model\\Attributes\\Transform;\r use Neoan\\Model\\Transforme"},{"id":"computed","title":"Computed values","context":"A model is often more than a mapping to persistent data. Sometimes we want to derive information from that data and have our controllers consume it\r with more ease. Computed values are meant to help with this.\r \r \r namespace App\\Models;\r use Neoan\\Model\\Model;\r use Neoan\\Model\\Attributes\\IsPrimaryKey;\r use Neoan\\Model\\Attributes\\IsF"},{"id":"hooks","title":"Hooks","context":"Interacting with models fires Events and every model is listenable.\r In some cases relying on \"external\" logic to facilitate things that should run \"whenever I save\" might better be addressed directly.\r To do just that, you can choose to overwrite the following model-methods"},{"id":"collections","title":"Collections","context":"A collection instance is useful when dealing with multiple different instances of a given model.\r This is commonly the case when retrieving multiple entries. A collection is iterable and offers useful\r methods:\r \r \r Method\r Description"},{"id":"usage","title":"Using a model","context":"Retrieval\r Conditions\r \r Let's begin by exploring how conditions work.\r Conditions are passed into a model as assoc arrays\r \r \r $condition = [\r 'email' => 'adam@email.com'\r ];\r $user = User::retrieveOne($condition);\r \r \r With the MySQL adapter, this roughly translates to \r SE"},{"id":"pagination","title":"Pagination","context":"Pagination is a common task when dealing with lists and\/or large numbers of expected results.\r LENKRAD simplified this process.\r \r \r $page = 1;\r $resultsPerPage = 25;\r return User::paginate($page, $resultsPerPage)\r \/\/ you can use the regular condition array to specify\r ->where(['^deletedAt])\r \/\/ newest users first? Let's get the las"},{"id":"magic","title":"Magic methods","context":"LENKRAD avoids magic methods as we believe in empowering your IDE to do its job without having to\r write comments like it's 2015. However, models DO have a __call-implementation and attributes can make use of it.\r Out of the box, the attribute IsForeignKey uses it. Let's revive our movie class and add the property \"director\"\r to see it in action:"}],"url":"\/docs\/models"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/request.html","topic":"request","description":"General flow  Request    Your logic    Response  Where it all begins...  The Request class Request Unit Testing Using Request Request guards   The Request class  As reacting on requests is likely the most common prerequisite to your programmatic logic, LENKRAD has made handling requests as easy as...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\n<!--    url: \/docs\/request --> <h1>Request<\/h1> <h2>General flow<\/h2> <div class=\"grid grid-cols-5 mb-5 gap-x-2\"> <div class=\"bg-contrast p-2 border-accent border-r-2\">Request<\/div> <div class=\"border-neutral-light border-t-1  place-center-stretch relative\"> <div class=\"absolute border-neutral-light border-t-1 border-r-1 p-1 right-0\" style=\"transform: rotate(45deg); top: -0.4rem\"><\/div> <\/div> <div class=\"bg-contrast p-2\">Your logic<\/div> <div class=\"border-neutral-light border-t-1 place-center-stretch relative\"> <div class=\"absolute border-neutral-light border-t-1 border-r-1 p-1 right-0\" style=\"transform: rotate(45deg); top: -0.4rem\"><\/div> <\/div> <div class=\"bg-contrast p-2\">Response<\/div> <\/div> <p>Where it all begins...<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/request#class\" class=\"button-contrast-light\">The Request class<\/a> <a href=\"\/docs\/request#request-test\" class=\"button-contrast-light\">Request Unit Testing<\/a> <a href=\"\/docs\/request#usage\" class=\"button-contrast-light\">Using Request<\/a> <a href=\"\/docs\/request#guard\" class=\"button-contrast-light\" version=\">0.3\">Request guards<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The Request class<\/h2> <p> As reacting on requests is likely the most common prerequisite to your programmatic logic, LENKRAD has made handling requests as easy as possible. Let's first look at the static public methods: <\/p> <div class=\"grid grid-cols-2 gap-3\"> <div class=\"border-b-2 border-primary font-lg\">Method<\/div> <div class=\"border-b-2 border-primary font-lg\">Description<\/div> <p>Request::getQueries()<\/p> <p>Returns assoc array of query parameters<\/p> <p>Request::getQuery(string $name)<\/p> <p>Return the value of the specified query parameter, or null<\/p> <p>Request::getRequestMethod()<\/p> <p>Returns a Neoan\\Enums\\RequestMethod case<\/p> <p>Request::getRequestUri()<\/p> <p>Returns a string containing the request-uri<\/p> <p>Request::getInputs()<\/p> <p>Returns client-payload, regardless of method<\/p> <p>Request::getInput(string $name)<\/p> <p>Returns the value of the specified input, or null<\/p> <p>Request::getParameters()<\/p> <p>Returns assoc array of route-specific parameters (see <a href=\"\/docs\/routing#parameter\">Route parameter<\/a>)<\/p> <p>Request::getParameter(string $name)<\/p> <p>Returns the value of the specified parameter, or null<\/p> <p>Request::getInstance(Request $mockInstance = null)<\/p> <p>Return the current instance of the Request facade. (e.g. to mock & test)<\/p> <\/div> <p>Additionally, some useful properties are public:<\/p> <code class=\"language-php block\">$request = Request::getInstance();<\/code> <div class=\"grid grid-cols-2 gap-3 mt-3\"> <div class=\"border-b-2 border-primary font-lg\">Property<\/div> <div class=\"border-b-2 border-primary font-lg\">Description<\/div> <p>$request->requestHeaders<\/p> <p>Array containing all collected headers<\/p> <p>$request->files<\/p> <p>Array containing all files submitted via form-data<\/p> <p>$request->webPath<\/p> <p>Returns string of actual webPath before any sanitation and parsing<\/p> <\/div> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"request-test\">Request Unit Testing<\/h2> <p> To ease testing of your application code, you can set\/override values at runtime. This is true for all public properties. Additionally, the following setters work statically: <\/p> <div class=\"grid grid-cols-2 gap-3\"> <div class=\"border-b-2 border-primary font-lg\">Method<\/div> <div class=\"border-b-2 border-primary font-lg\">Description<\/div> <p>Request::setParameters(array $parameters)<\/p> <p>Expects assoc array<\/p> <p>Request::setQueries(array $queryParameters)<\/p> <p>Expects assoc array<\/p> <p>Request::detachInstance()<\/p> <p>Resets the singleton to null. (NOTE: you likely want to run getInstance() with a mock-instance after that to generate a new instance)<\/p> <\/div> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"usage\">Using Request<\/h2> <p> You <em>must not<\/em> inject the Request into your controllers. Instead, the static methods can be used after app-instantiation anywhere in your code. <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> ... use Neoan\\Request\\Request; class RandomClass extends Routable { public function __invoke(MyValidationClass $validation) { [ 'terms-accepted' => $accepted, 'email' => $requesterEmail ] = Request::getInputs(); if(!$accepted || !$validation->isValidEmail($requesterEmail)){ $this->doSomething(); } $this->addToNewsletter($requesterEmail); Response::redirect('\/dashboard') } ... } <\/code><\/pre> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\" version=\">0.3\"> <h2 id=\"guard\">Request guards<\/h2> <p> In order to provide a clean input\/output structure while separating concerns in a clean manner, you can use validation wrappers called \"Request guards\". This pattern allows for abstraction similar to models, but for incoming data. Let's take the example above and make the following changes: <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> ... class RandomClass extends Routable { public function __invoke(RandomGuard $request) { \/\/ if we are here, all existence and validity is already taken care of $this->addToNewsletter($request->email); Response::redirect('\/dashboard') } } <\/code><\/pre> <p> Our RandomGuard extends RouteGuard and may look like this <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> ... use Neoan\\Request\\RequestGuard; class RandomGuard extends RequestGuard { \/\/ the request REQUIRES the property \"email\" public string $email; \/\/ the request CAN have the property \"gender\" public ?string $gender; \/\/ the request's value of \"termsAccepted\" is cast to boolean public bool $termsAccepted; \/\/ we want to further expand on what should be blocked public function __invoke(): static { \/\/ let the parent do it's magic parent::__invoke(); \/\/ now let's block requests that don't fulfil our additional requirements $validation = new MyValidationClass(); if(!$validation->isValidEmail($this->email) || !$this->termsAccepted) { $response = Response::getInstance(); $response->setStatusCode(400); $response->respond('Bad Request'); } return $this; } } <\/code><\/pre> <p> The <em>RequestGuard<\/em> class uses constants to manipulate default behavior. To change the default behavior, simply overwrite them in your guard. <\/p> <div class=\"grid grid-cols-2 gap-3\"> <div class=\"border-b-2 border-primary font-lg\">Constant<\/div> <div class=\"border-b-2 border-primary font-lg\">Description<\/div> <p>const requestTypes = ['query', 'parameter', 'post'];<\/p> <p>Reads from LENKRAD's request types in the provided order. You can change the order or exclude types.<\/p> <p>const throwOnError = true;<\/p> <p> By default, the guard stops execution and responds with a 400 status code explaining what is missing\/malformed. If you want to handle errors yourself, simply set this to false; <\/p> <\/div> <p> As Guards can be chained, you can use them for complex privilege handling as well. <\/p> <\/div>\n<\/section>","headlines":[{"id":"class","title":"The Request class","context":"As reacting on requests is likely the most common prerequisite to your programmatic logic, LENKRAD has made handling requests as easy as possible. Let's first look at the static public methods:   Method Description Request::getQueries() Re"},{"id":"request-test","title":"Request Unit Testing","context":"To ease testing of your application code, you can set\/override values at runtime. This is true for all public properties. Additionally, the following setters work statically:   Method Description Request::setParameters(array $parameters) E"},{"id":"usage","title":"Using Request","context":"You must not inject the Request into your controllers. Instead, the static methods can be used after app-instantiation anywhere in your code.   ... use Neoan\\Request\\Request; class RandomClass extends Routable { public function __invoke(MyValidationClass $validation) { [ 'terms-accepted' => $accepted, 'email' => $requesterEma"},{"id":"guard","title":"Request guards","context":"In order to provide a clean input\/output structure while separating concerns in a clean manner, you can use validation wrappers called \"Request guards\". This pattern allows for abstraction similar to models, but for incoming data. Let's take the example above and make the following changes:   ... class RandomClass extends Routable { p"}],"url":"\/docs\/request"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/requestguard.html","topic":"request guards","description":"Incoming requests often require a few checks in order to evaluate their integrity. These checks include\r \r \r Is the payload\/the query malformed?\r Does the payload correlate to the right types?\r Does the payload need to be sanitized?\r \r \r The Concept\r Error behavior\r Request types\r \r \r The Concep...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r <!--    url: \/docs\/requestguard -->\r <h1>Request Guards<\/h1>\r <p>\r Incoming requests often require a few checks in order to evaluate their integrity. These checks include\r <\/p>\r <ul>\r <li>Is the payload\/the query malformed?<\/li>\r <li>Does the payload correlate to the right types?<\/li>\r <li>Does the payload need to be sanitized?<\/li>\r <\/ul>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/requestguard#concept\" class=\"button-contrast-light\">The Concept<\/a>\r <a href=\"\/docs\/requestguard#error-behavior\" class=\"button-contrast-light\">Error behavior<\/a>\r <a href=\"\/docs\/requestguard#request-types\" class=\"button-contrast-light\">Request types<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"concept\">The Concept<\/h2>\r <p>\r A request guard captures the request and is in its easiest form similar to a model declaration.\r By defining properties we decide which properties are optional or required, which properties should be cast into a type,\r and what default values should be considered. Without further configuration, a request guard ends a request with an error message before executing your controller.\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r class MyRequest extends \\Neoan\\Request\\RequestGuard\r {\r \/\/ the request REQUIRES the property \"email\"\r public string $email;\r \/\/ the request REQUIRES the property \"name\"\r public string $name;\r \/\/ the request CAN have the property \"age\",\r \/\/ which will be cast to integer\r public ?int $age;\r \/\/ the request's value of \"termsAccepted\"\r \/\/ is cast to boolean\r public bool $termsAccepted;\r \/\/ the request's value of \"gender\" is\r \/\/ cast to the custom enum \"GenderEnum\"\r public ?GenderEnum $gender;\r }\r <\/code><\/pre>\r <p>\r If the request does not contain all required properties, the request will be blocked.\r In order to use a request guard for a particular endpoint, inject the guard in the controller.\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r class MyEndpoint implements Routable\r {\r \/\/ Inject \"MyRequest\" as $request\r public function __invoke(MyRequest $request): array\r {\r \/\/ let's assume we want to create a new person (model)\r $person = new Person();\r $person->email = $request->email;\r if(isset($request->gender){\r $person->gender = $request->gender;\r }\r ...\r \/*\r * or \"lazy\": (new Person((array) $request))->store();\r *\/\r }\r }\r <\/code><\/pre>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"error-behavior\">Error behavior<\/h2>\r <p>\r If a request is not valid, a 400 HTTP response will be sent along with a reason (e.g. \"missing property `x`\", etc.).\r However, you might want to turn that behavior off if necessary (e.g. for custom error handling).\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r class MyRequest extends \\Neoan\\Request\\RequestGuard\r {\r \/\/ if throwOnError is set to false, the default behavior of blocking the request is overridden\r const throwOnError = false;\r public string $email;\r public string $name;\r public ?int $age;\r public bool $termsAccepted;\r public ?GenderEnum $gender;\r }\r <\/code><\/pre>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"request-types\">Request Types<\/h2>\r <p>\r By default, the request guard will accept requests of the following types:\r <\/p>\r <ul>\r <li>'query', Query parameters<\/li>\r <li>'parameter', as defined as a route-part<\/li>\r <li>'post', payload submitted via POST, PUT, PATCH<\/li>\r <li>'file', binary file uploads<\/li>\r <\/ul>\r <p>\r You can limit the considered request types by the constant \"requestTypes\".\r <\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r class MyRequest extends \\Neoan\\Request\\RequestGuard\r {\r \/\/ only consider \"query\" and \"parameter\"\r const requestTypes = ['query', 'parameter'];\r public string $email;\r public string $name;\r public ?int $age;\r public bool $termsAccepted;\r public ?GenderEnum $gender;\r }\r <\/code><\/pre>\r <\/div>\r\n<\/section>","headlines":[{"id":"concept","title":"The Concept","context":"A request guard captures the request and is in its easiest form similar to a model declaration.\r By defining properties we decide which properties are optional or required, which properties should be cast into a type,\r and what default values should be considered. Without further configuration, a request guard ends a request with an error message before executing your controller."},{"id":"error-behavior","title":"Error behavior","context":"If a request is not valid, a 400 HTTP response will be sent along with a reason (e.g. \"missing property `x`\", etc.).\r However, you might want to turn that behavior off if necessary (e.g. for custom error handling).\r \r \r class MyRequest extends \\Neoan\\Request\\RequestGuard\r {\r \/\/ if throwOnError is set to false, the default behavior o"},{"id":"request-types","title":"Request Types","context":"By default, the request guard will accept requests of the following types:\r \r \r 'query', Query parameters\r 'parameter', as defined as a route-part\r 'post', payload submitted via POST, PUT, PATCH\r 'file', binary file uploads\r \r \r You can limit the considered request types by the constant \"requestTypes\"."}],"url":"\/docs\/requestguard"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/response.html","topic":"response","description":"General flow  Request    Your logic    Response   In most scenarios, you won't interact with the Response class directly after your defaults have been set up.   The Response class Setting defaults   The Response class  The Response class is used by internal processes to handle the http-answer. When...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\n<!--    url \/docs\/response --> <h1>Response<\/h1> <h2>General flow<\/h2> <div class=\"grid grid-cols-5 mb-5 gap-x-2\"> <div class=\"bg-contrast p-2\">Request<\/div> <div class=\"border-neutral-light border-t-1  place-center-stretch relative\"> <div class=\"absolute border-neutral-light border-t-1 border-r-1 p-1 right-0\" style=\"transform: rotate(45deg); top: -0.4rem\"><\/div> <\/div> <div class=\"bg-contrast p-2\">Your logic<\/div> <div class=\"border-neutral-light border-t-1 place-center-stretch relative\"> <div class=\"absolute border-neutral-light border-t-1 border-r-1 p-1 right-0\" style=\"transform: rotate(45deg); top: -0.4rem\"><\/div> <\/div> <div class=\"bg-contrast p-2 border-accent border-r-2\">Response<\/div> <\/div> <p> In most scenarios, you won't interact with the Response class directly after your defaults have been set up. <\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/response#class\" class=\"button-contrast-light\">The Response class<\/a> <a href=\"\/docs\/response#response-defaults\" class=\"button-contrast-light\">Setting defaults<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The Response class<\/h2> <p> The Response class is used by internal processes to handle the http-answer. When the last class implementing Routable in your logic chain returns, the Route class automatically passes the accumulated results to the output defined in the current <a href=\"\/docs\/routing\">route<\/a> or based on <a href=\"\/docs\/response#response-defaults\">your settings<\/a>. Like any other part of LENKRAD, the process is fully exposed to you. The Response class offers the following static methods: <\/p> <div class=\"grid grid-cols-2 gap-3\"> <div class=\"border-b-2 border-primary font-lg\">Method<\/div> <div class=\"border-b-2 border-primary font-lg\">Description<\/div> <p>setDefaultOutput(ResponseOutput $output)<\/p> <p>Takes a Neoan\\Enums\\ResponseOutput case. The default is ResponseOutput::JSON<\/p> <p>output($data, array $renderOptions)<\/p> <p>Manually triggers immediate output with given specifications<\/p> <p>getDefaultOutput()<\/p> <p>Returns default Neoan\\Enums\\ResponseOutput case<\/p> <p>setDefaultRenderer(string $renderer)<\/p> <p> Expects classname of class implementing Neoan\\Render\\RenderEngine. (You can set alternative Renderers at a route-level as well) <\/p> <p>json(Serializable $data)<\/p> <p> Serializes provided data to json and responds immediately (with corresponding header). Method gets called internally if defaultOutput is set to ResponseOutput::JSON <\/p> <p> html(mixed $data, ?string $view) <\/p> <p> Normalizes $data (DataNormalization instance), applies it to provided view and immediately responds with output. Method gets called internally if defaultOutput is set to ResponseOutput::HTML <\/p> <p> setStatuscode(int $httpResponseCode) <\/p> <p> Sets response code in response header. <\/p> <p> redirect(string $whereTo) <\/p> <p> Redirects to specified location and stops execution. <\/p> <p> getInstance(?ResponseInterface = null) <\/p> <p>Returns Response instance. A mock response can be passed in (for testing)<\/p> <p>detachInstance()<\/p> <p>Resets singleton instance.<\/p> <\/div> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"response-defaults\">Setting defaults<\/h2> <p> If you are <a href=\"\/docs\/routing#attribute\">routing by attributes<\/a>, there are no default settings you need to worry about regarding the response. If you define your routes classically, you might want to simplify your route definitions by setting a default for the most common case of route. <\/p> <h3>Server Side Rendered Application<\/h3> <p>If your routes tend to be rendered pages, consider <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> use Neoan\\Response\\Response; use Neoan\\Enums\\ResponseOutput; Response::setDefaultOutput(ResponseOutput::HTML) <\/code><\/pre> <h3>JSON API<\/h3> <p>If you are building a pure backend, consider<\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> use Neoan\\Response\\Response; use Neoan\\Enums\\ResponseOutput; Response::setDefaultOutput(ResponseOutput::JSON); <\/code><\/pre> <blockquote> You can always overwrite the response-type on the route level. <\/blockquote> <h3>Programmatic example<\/h3> <pre class=\"normalize-code\"><code class=\"language-php\"> use Neoan\\Response\\Response; use Neoan\\Request\\Request; use Neoan\\Enums\\ResponseOutput; \/\/ In a monolith, we might have api-routes and web-routes $isApi = str_starts_with(Request::getRequestUri(), '\/api\/'); Response::setDefaultOutput($isApi ? ResponseOutput::JSON : ResponseOutput::HTML); <\/code><\/pre> <\/div>\n<\/section>","headlines":[{"id":"class","title":"The Response class","context":"The Response class is used by internal processes to handle the http-answer. When the last class implementing Routable in your logic chain returns, the Route class automatically passes the accumulated results to the output defined in the current route or based on your settings. Like any other part of LENKRAD, the proces"},{"id":"response-defaults","title":"Setting defaults","context":"If you are routing by attributes, there are no default settings you need to worry about regarding the response. If you define your routes classically, you might want to simplify your route definitions by setting a default for the most common case of route.  Server Side Rendered Application If your routes tend to be rendered pages, consider"}],"url":"\/docs"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/routing.html","topic":"routing","description":"Routing of endpoints can be handled by attribute or declaration. This page will explain both.  The Route class Middleware Chaining Route Parameters Direct Injections Custom Response Handling Attribute Routing   The Route class  Like most core-classes, Route is used statically while maintaining a si...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\n<!--  url: \/docs\/routing  --> <h1>Routing<\/h1> <p>Routing of endpoints can be handled by attribute or declaration. This page will explain both.<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/routing#class\" class=\"button-contrast-light\">The Route class<\/a> <a href=\"\/docs\/routing#chaining\" class=\"button-contrast-light\">Middleware Chaining<\/a> <a href=\"\/docs\/routing#parameter\" class=\"button-contrast-light\">Route Parameters<\/a> <a href=\"\/docs\/routing#inject\" class=\"button-contrast-light\">Direct Injections<\/a> <a href=\"\/docs\/routing#response\" class=\"button-contrast-light\">Custom Response Handling<\/a> <a href=\"\/docs\/routing#attribute\" class=\"button-contrast-light\">Attribute Routing<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The Route class<\/h2> <p> Like most core-classes, <em>Route<\/em> is used statically while maintaining a single instance of itself. It's responsible for registering routes. <\/p> <h3>Main methods<\/h3> <div class=\"grid grid-cols-3 gap-3 w-full overflow-x-auto overflow-x-auto\"> <div class=\"border-b-2 border-primary font-lg\">Method<\/div> <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div> <p>Route::get<\/p> <p class=\"span-x-2\">Registers a GET request<\/p> <p>Route::post<\/p> <p class=\"span-x-2\">Registers a POST request<\/p> <p>Route::put<\/p> <p class=\"span-x-2\">Registers a PUT request<\/p> <p>Route::patch<\/p> <p class=\"span-x-2\">Registers a PATCH request<\/p> <p>Route::delete<\/p> <p class=\"span-x-2\">Registers a DELETE request<\/p> <p>Route::request<\/p> <p class=\"span-x-2\">Registers other\/custom requests<\/p> <\/div> <p> With the exception of <em>Route::request<\/em>, these methods all take the same arguments. LENKRAD intends to work with your IDE and tries to reduce string usage by the user. For these methods, this means that classnames are provided to a route. A class must fulfill the following requirements:  <\/p> <ul> <li>Implements Neoan\\Routing\\Interfaces\\Routable<\/li> <li>Has __invoke method<\/li> <li>Returns a serializable result, a <a href=\"\/docs\/models\">Model, a Collection<\/a> or a DataNormalization instance<\/li> <\/ul> <h3>Example or a routable class<\/h3> <pre class=\"normalize-code\"><code class=\"language-php\"> ?php namespace App; use Neoan\\Routing\\Interfaces\\Routable; class Controller implements Routable { public function __invoke(): array { return ['test' => 'message']; } } <\/code><\/pre> <h3>Example of a route using <em>Controller.php<\/em><\/h3> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App; use Neoan\\Routing\\Route; Route::get('\/test', Controller::class); <\/code><\/pre> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"chaining\">Middleware Chaining<\/h2> <p>A route definition can chain routable classes as needed:<\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App; use Neoan\\Routing\\Route; Route::get('\/test', Auth::class, ReadUserFile::class, Controller::class); <\/code><\/pre> <p>This will execute one class after another. For a better understanding on how to utilize this feature, please refer to the <a href=\"\/docs\/middleware\">Middleware chapter<\/a> of this documentation<\/p> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"parameter\">Route parameter<\/h2> <p> In both API & SSR routes, variable parameters are a common necessity. Like many other frameworks in various languages, LENKRAD solves this by markup: <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App; use Neoan\\Routing\\Route; \/\/ Route will respond to \/test\/{anything} Route::get('\/test\/:name', Controller::class); \/\/ Route will respond to \/test and \/test\/{anything} Route::get('\/test\/:name*', Controller::class); \/\/ Multiple parameters are possible Route::get('\/test\/:name\/:id*', Controller::class); <\/code><\/pre> <h3>Variable usage<\/h3> <p> Routes using parameters provide their content to <a href=\"\/docs\/request\">Request<\/a>. To indicate a part of the route as parameter, prefix it with <em>: (colon)<\/em>. To indicate a part of the route is an optional parameter, additionally append it with <em>* (asterisks)<\/em> <\/p> <blockquote> Careful when chaining parameters. It's a common trap to pollute namespaces. <\/blockquote> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"inject\">Direct Injection<\/h2> <p> In very simple projects or routes, the necessity for logic might be overkill. You can therefore directly pass values to the response instead of using a class. <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App; use Neoan\\Routing\\Route; use Neoan\\Request\\Request; Route::get('\/test\/:name') ->inject(Request::getParameters()); <\/code><\/pre> <blockquote> Note that without additional changes to defaults, this only works for the standard JSON response. <\/blockquote> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"response\">Custom response handling<\/h2> <p> We speak of an either\/or when talking about responses. However, in reality you might have different response requirements for a particular route. This is why it's possible to overwrite the default behavior per route. <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App; use Neoan\\Routing\\Route; use Neoan\\Response\\Response; \/\/ using the default response handler, but overwriting its current default handling Route::get('\/test', Controller::class) ->view('templates\/test.html') ->response([Response::class,'html']); \/\/ using your own response handler and its method \"answer\" Route::get('\/test', Controller::class) ->response([MyResponseHandler::class,'answer']); <\/code><\/pre> Response handling is further explained in <a href=\"\/docs\/response\">Response<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"attribute\">Attribute Routing<\/h2> <p> Ever since Ruby on Rails exploded onto the world, annotational routing took the developer's interest. In LENKRAD, you can achieve this with attributes on the class-level. <\/p> <h3>Setup<\/h3> <p> In order to make use of this convenient way of defining routes, add the following lines to your index.php in your public folder: <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> ... $app = new NeoanApp( $setup, $cliPath); \/\/ enable attribute routing $namespaceToExploreRecursively = 'App'; $app->invoke(new Neoan\\Routing\\AttributeRouting($namespaceToExploreRecursively)); $app->run(); <\/code><\/pre> <h3>Examples<\/h3> <div class=\"grid grid-cols-6 gap-3 w-full overflow-x-auto\"> <div class=\"border-b-2 border-primary font-lg\">Attribute<\/div> <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div> <div class=\"border-b-2 border-primary font-lg span-x-3\">Example<\/div> <p>Web<\/p> <p class=\"span-x-2\">Resolves html routes<\/p> <p class=\"span-x-3\">#[Web('\/test', 'test.html')]<\/p> <p>Get<\/p> <p class=\"span-x-2\">Resolves API-GET routes<\/p> <p class=\"span-x-3\">#[Get('\/api\/test')]<\/p> <p>Post<\/p> <p class=\"span-x-2\">Resolves API-GET routes<\/p> <p class=\"span-x-3\">#[Post('\/api\/test', AuthGuard::class)]<\/p> <p>Put<\/p> <p class=\"span-x-2\">Resolves API-PUT routes<\/p> <p class=\"span-x-3\">#[Put('\/api\/test', AuthGuard::class)]<\/p> <\/div> <p> Generally, the behavior is identical to declaring routes manually. <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> ?php namespace App; \/\/ Don't forget the use-statement! use Neoan\\Routing\\Attributes\\Get; use Neoan\\Routing\\Interfaces\\Routable; #[Get('\/api\/test')] class Controller implements Routable { public function __invoke(): array { return ['test' => 'message']; } } <\/code><\/pre> <\/div> <\/section>","headlines":[{"id":"class","title":"The Route class","context":"Like most core-classes, Route is used statically while maintaining a single instance of itself. It's responsible for registering routes.  Main methods  Method Description Route::ge"},{"id":"chaining","title":"Middleware Chaining","context":"A route definition can chain routable classes as needed:  namespace App; use Neoan\\Routing\\Route; Route::get('\/test', Auth::class, ReadUserFile::class, Controller::class);  This will execute one class after another. For a better understanding on how to utilize this feature, please refer to the"},{"id":"parameter","title":"Route parameter","context":"In both API & SSR routes, variable parameters are a common necessity. Like many other frameworks in various languages, LENKRAD solves this by markup:   namespace App; use Neoan\\Routing\\Route; \/\/ Route will respond to \/test\/{anything} Route::get('\/test\/:name', Controller::class); \/\/ Route will respond to \/test and \/test\/{anything} Rout"},{"id":"inject","title":"Direct Injection","context":"In very simple projects or routes, the necessity for logic might be overkill. You can therefore directly pass values to the response instead of using a class.   namespace App; use Neoan\\Routing\\Route; use Neoan\\Request\\Request; Route::get('\/test\/:name') ->inject(Request::getParameters());   Note that without a"},{"id":"response","title":"Custom response handling","context":"We speak of an either\/or when talking about responses. However, in reality you might have different response requirements for a particular route. This is why it's possible to overwrite the default behavior per route.   namespace App; use Neoan\\Routing\\Route; use Neoan\\Response\\Response; \/\/ using the default response handler, but overw"},{"id":"attribute","title":"Attribute Routing","context":"Ever since Ruby on Rails exploded onto the world, annotational routing took the developer's interest. In LENKRAD, you can achieve this with attributes on the class-level.  Setup  In order to make use of this convenient way of defining routes, add the following lines to your index.php in your public folder:   ... $app ="}],"url":"\/docs\/routing"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/setup.html","topic":"setup","description":"Unifying common setup necessities  The Setup class   The Setup class  Starting from version v0.2, the app requires an instance of the setup-helper. This simplifies the setup process greatly.  Main methods  Method Description set(string $key, mixed $value) Registers a value available throughout the...","content":"<div> <div version=\"<0.2\" class=\"bg-warning p-2 border-danger border-l-4 relative\"> <p> This topic isn't implemented in your version of LENKRAD. <\/p> <\/div> <section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <!-- url: \/docs\/setup --> <h1>Setup<\/h1> <p>Unifying common setup necessities<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-primary\">The Setup class<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The Setup class<\/h2> <p> Starting from version v0.2, the app requires an instance of the setup-helper. This simplifies the setup process greatly. <\/p> <h3>Main methods<\/h3> <div class=\"grid grid-cols-3 gap-3 w-full overflow-x-auto overflow-x-auto\"> <div class=\"border-b-2 border-primary font-lg\">Method<\/div> <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div> <p>set(string $key, mixed $value)<\/p> <p class=\"span-x-2\">Registers a value available throughout the app<\/p> <p>get(string $key)<\/p> <p class=\"span-x-2\">Retrieves a value<\/p> <p>getConfiguration()<\/p> <p class=\"span-x-2\">Retrieves an array of all setup values<\/p> <p>setPublicPath(string $path)<\/p> <p class=\"span-x-2\">Registers web-path<\/p> <p>setLibraryPath(string $path)<\/p> <p class=\"span-x-2\">Registers source-path<\/p> <p>setDatabaseAdapter(Adapter $adapter)<\/p> <p class=\"span-x-2\">Accepts instantiated Database adapter<\/p> <p>setSkeletonVariables(array $skeletonVariables)<\/p> <p class=\"span-x-2\">See <a href=\"\/docs\/templating?highlight=skeletonVariables\">templating (variables)<\/a><\/p> <p>setSkeletonComponentPlacement(string $skeletonComponentPlacement)<\/p> <p class=\"span-x-2\">See <a href=\"\/docs\/templating?highlight=placement\">templating (placement)<\/a><\/p> <p>setSkeletonHTML(string $skeletonHTML)<\/p> <p class=\"span-x-2\">See <a href=\"\/docs\/templating?highlight=skeletonPath\">templating (skeleton)<\/a><\/p> <p>setUseSkeleton(bool $useSkeleton)<\/p> <p class=\"span-x-2\">Set true for use of layout\/frame mode<\/p> <p>setDefault404(string $default404)<\/p> <p class=\"span-x-2\">Set own 404 page html<\/p> <p>setDefault500(string $default500)<\/p> <p class=\"span-x-2\">Set own system error page html<\/p> <p>setTemplatePath(string $templatePath)<\/p> <p class=\"span-x-2\">Set relative base path for templating<\/p> <\/div> <h3>Example with custom value<\/h3> <p>index.php<\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> ?php \/\/ \/public\/index.php use Neoan\\NeoanApp; use Neoan\\Routing\\Route; use Neoan\\Helper\\Setup; $projectPath = dirname(__DIR__); require_once $projectPath . '\/vendor\/autoload.php'; $pathToSourceFiles = $projectPath . '\/src'; $publicPath = __DIR__; $setup = new Setup(); $setup->setLibraryPath($pathToSourceFiles) ->setPublicPath($publicPath) \/\/ some arbitrary setup value ->set('globalArray', ['a']); $app = new NeoanApp($setup); ... \/\/ run application $app->run(); <\/code><\/pre> <p>Some controller<\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> ?php namespace App; use Neoan\\Routing\\Interfaces\\Routable; use Neoan\\Helper\\Setup; class Controller implements Routable { \/\/ auto-wire our setup instance public function __invoke(Setup $setup): array { \/\/ let's return our globalArray return $setup->get('globalArray'); } } <\/code><\/pre> <\/div> <\/section>\n<\/div>\n","headlines":[{"id":"class","title":"The Setup class","context":"Starting from version v0.2, the app requires an instance of the setup-helper. This simplifies the setup process greatly.  Main methods  Method Description set(string $key, mixed $value)"}],"url":"\/docs\/setup"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/templating.html","topic":"templating & rendering","description":"Rendering & templating in LENKRAD - the basics\r \r About rendering\r The Render class\r The Templating class\r \r \r About rendering\r \r It's important to understand how LENKRAD handles rendering in general. This page assumes that the default\r Renderer is used. Please refer to Response and Custom respons...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\r <!--    url: \/docs\/templating -->\r <h1>Templating & Rendering<\/h1>\r <p>Rendering & templating in LENKRAD - the basics<\/p>\r <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\">\r <a href=\"\/docs\/templating#ssr\" class=\"button-contrast-light\">About rendering<\/a>\r <a href=\"\/docs\/templating#render\" class=\"button-contrast-light\">The Render class<\/a>\r <a href=\"\/docs\/templating#class\" class=\"button-contrast-light\">The Templating class<\/a>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"ssr\">About rendering<\/h2>\r <p>\r It's important to understand how LENKRAD handles rendering in general. This page assumes that the default\r Renderer is used. Please refer to <a href=\"\/docs\/response\">Response<\/a> and <a\r href=\"\/docs\/routing#response\">Custom response handling<\/a>\r for possibilities to influence rendering.\r <\/p>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"render\">The Render class<\/h2>\r <p>\r The Renderer class has the following static methods:\r <\/p>\r <div class=\"grid grid-cols-2 gap-3\">\r <div class=\"border-b-2 border-primary font-lg\">Method<\/div>\r <div class=\"border-b-2 border-primary font-lg\">Description<\/div>\r <p>setTemplatePath(string $path)<\/p>\r <p>Sets the entry level of template-arguments<\/p>\r <p>getInstance(Renderer $mockInstance = null)<\/p>\r <p>Returns an existing instance if present, creates a new instance if initial or overrides the used instance\r with a mock instance (testing)<\/p>\r <p>setHtmlSkeleton(string $skeletonPath, string $placement = 'main', array $skeletonVariables = [])<\/p>\r <p>See example below<\/p>\r <p>render(array | DataNormalization $data, $view)<\/p>\r <p>Manually triggers rendering (used automatically on last procedural chain, you likely will never need\r it)<\/p>\r <p>detachInstance()<\/p>\r <p>Resets internal singleton to null<\/p>\r <p>getTemplatePath()<\/p>\r <p>Returns string with set template path<\/p>\r <p>getHtmlSkeletonPath()<\/p>\r <p>Returns string of set skeleton path<\/p>\r <p>getHtmlComponentPlacement()<\/p>\r <p>Returns string of set component placement<\/p>\r <\/div>\r <p>\r The default rendering class can either be used with individually rendered HTML files or using a surrounding\r layout\r where route-specific content is placed in a predefined container. Here, we assume the latter, also referred\r to as skeleton setup.\r <\/p>\r <h3 id=\"#skeleton-structure\">Skeleton structure<\/h3>\r <div class=\"m-t-5 m-b-5 border-neutral-light border-1 p-4 relative\">\r <p class=\"font-md absolute -top-5 bg-neutral pl-2 pr-2\">\/src\/views\/skeleton.html<\/p>\r <p>This file contains the \"frame\"-html. Maybe header, menus, footer, etc.<\/p>\r <div class=\"m-t-5 m-b-5 border-primary-dark border-1 p-4 relative\">\r <p class=\"font-md absolute -top-5 bg-neutral pl-2 pr-2\">Respective component\/route HTML<\/p>\r <p>The render class places the route's defined HTML at a specified location (defaults to \"main\")<\/p>\r <\/div>\r <\/div>\r <p>The method <em>setHtmlSkeleton<\/em> is best explained by example.<\/p>\r <h3>Example<\/h3>\r <p>1. \/src\/views\/skeleton.html (regarding the curly bracket markup, see <a href=\"\/docs\/templating#class\">the\r Template class<\/a>)<\/p>\r <pre class=\"normalize-code\"><code class=\"language-html\" data-class=\"strip-html\" data-id=\"skeleton\"><\/code><\/pre>\r <p>2. \/src\/Home\/Home.php<\/p>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ?php\r namespace App\\Home;\r use Neoan\\Routing\\Interfaces\\Routable;\r class Home implements Routable\r {\r public function __invoke(): array\r {\r return ['fromHome' => 'Hello there, Obi Wan Kenobi']\r }\r }\r <\/code><\/pre>\r <p>3. \/src\/Home\/view.html<\/p>\r <pre class=\"normalize-code\"><code class=\"language-html\" data-class=\"strip-html\" data-id=\"view\"><\/code><\/pre>\r <p>4. \/public\/index.php<\/p>\r <div>\r <pre version=\"0.1\" class=\"normalize-code\"><code class=\"language-php\">\r use Neoan\\NeoanApp;\r use Neoan\\Routing\\Route;\r use Neoan\\Render\\Renderer;\r use Neoan\\Enums\\ResponseOutput;\r use Neoan\\Response\\Response;\r use App\\Home\\Home;\r $projectPath = dirname(__DIR__);\r require_once $projectPath . '\/vendor\/autoload.php';\r $pathToSourceFiles = $projectPath . '\/src';\r $publicPath = __DIR__;\r $app = new NeoanApp($pathToSourceFiles, $publicPath);\r \/\/ to simplify our life, let's set this app to default to SSR ...\r Response::setDefaultOutput(ResponseOutput::HTML);\r \/\/ ... and set a default entry path for our views\r Renderer::setTemplatePath('src\/');\r \/\/ Let's set up our skeleton\r Renderer::setHtmlSkeleton(\r 'src\/views\/skeleton.html', \/\/ our skeleton HTML\r 'main',     \/\/ our component placement\r [\r 'year' => '2022',\r 'title' => 'My App'\r ]           \/\/ lastly, we can set default variables used in our skeleton\r );\r \/\/ register a test route\r Route::get('\/', Home::class)->view('Home\/view.html');\r \/\/ run application\r $app->run();\r <\/code><\/pre>\r <\/div>\r <div>\r <pre version=\">0.1\" class=\"normalize-code\"><code class=\"language-php\">\r use Neoan\\NeoanApp;\r use Neoan\\Helper\\Setup;\r use Neoan\\Routing\\Route;\r use Neoan\\Render\\Renderer;\r use Neoan\\Enums\\ResponseOutput;\r use Neoan\\Response\\Response;\r use App\\Home\\Home;\r $projectPath = dirname(__DIR__);\r require_once $projectPath . '\/vendor\/autoload.php';\r $setup = new Setup();\r $setup->setPublicPath($projectPath . '\/public')\r ->setLibraryPath($projectPath . '\/src')\r \/\/ set template path relative to composer file path\r ->setTemplatePath('src\/')\r \/\/ enable the use of a skeleton\r ->setUseSkeleton(true)\r \/\/ what is our skeleton HTML?\r ->setSkeletonHTML('src\/views\/skeleton.html')\r \/\/ which variable to use for component placement\r ->setSkeletonComponentPlacement('main')\r \/\/ finally, let's set default variables\r ->setSkeletonVariables([\r 'year' => '2022',\r 'title' => 'My App'\r ]);\r $app = new NeoanApp($setup, $publicPath);\r \/\/ register a test route\r Route::get('\/', Home::class)->view('Home\/view.html');\r \/\/ run application\r $app->run();\r <\/code><\/pre>\r <\/div>\r <blockquote>\r We're lumping everything in the index file to show everything at one glance.\r Feel free to have a look at our starter projects to get suggestions of how to structure your\r real-life project.\r <\/blockquote>\r <\/div>\r <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\">\r <h2 id=\"class\">The Template class<\/h2>\r <p>\r LENKRAD ships with <a href=\"https:\/\/packagist.org\/packages\/neoan3-apps\/template\">neoan3-apps\/template<\/a> as\r the default\r templating mechanism. Documentation for the package is provided, so here we only provide a very basic\r example to get\r you started.\r <\/p>\r <h3>e.g. in \/src\/MyRoute\/MyRoute.php<\/h3>\r <pre class=\"normalize-code\"><code class=\"language-php\">\r ...\r #[Web('\/my-route', '\/MyRoute\/view.html')]\r class MyRoute implements Routable\r {\r public function __invoke(NeoanApp $app): array\r {\r $search = new Search();\r \/\/ Let's spoof a search\r Request::setQueries(['query' => 'model']);\r return [\r 'boolean' => true,\r 'results' => $search($app)['sections'],\r 'today' => date('m\/d\/Y')\r ];\r }\r }\r <\/code><\/pre>\r <h3>e.g. in \/src\/MyRoute\/view.html<\/h3>\r <pre class=\"normalize-code\"><code class=\"language-html\" data-class=\"strip-html\"\r data-id=\"one\">\r <\/code><\/pre>\r <h3>Result<\/h3>\r <div class=\"bg-contrast p-3\">\r <section>\r <h1 n-if=\"boolean\">{{today}}<\/h1>\r <\/section>\r <table>\r <tr n-for=\"results as result\">\r <td><a href=\"{{result.link}}\">{{result.link}}<\/a><\/td>\r <td>{{result.headline}}<\/td>\r <\/tr>\r <\/table>\r <\/div>\r <p>\r For translations and internationalization, you can use PHP's gettext or a package like\r <a href=\"https:\/\/github.com\/sroehrl\/php-i18n-translate#readme\">php-i18n-translate<\/a>\r <\/p>\r <\/div>\r <script type=\"text\/html\" id=\"one\">\r &lt;section&gt;\r &lt;!-- n-if: element removed if not true --&gt;\r &lt;!-- NOTE: can only have one child (element or text-node) --&gt;\r &lt;h1 n-if=\"boolean\"&gt;&#123;&#123;today}}&lt;\/h1&gt;\r &lt;\/section&gt;\r &lt;table&gt;\r &lt;!-- n-for: iterates similar to foreach --&gt;\r &lt;tr n-for=\"results as result\"&gt;\r &lt;!-- substitutions work in attributes as well --&gt;\r &lt;td&gt;&lt;a href=\"&#123;&#123;result.link}}\"&gt;&#123;&#123;result.link}}&lt;\/a&gt;&lt;\/td&gt;\r &lt;td&gt;&#123;&#123;result.headline}}&lt;\/td&gt;\r &lt;\/tr&gt;\r &lt;\/table&gt;\r <\/script>\r <script type=\"text\/html\" id=\"skeleton\">\r &lt;!DOCTYPE html&gt;\r &lt;html lang=\"en\"&gt;\r &lt;head&gt;\r &lt;meta charset=\"UTF-8\"&gt;\r &lt;title&gt;&#123;&#123;title}}&lt;\/title&gt;\r &lt;\/head&gt;\r &lt;body&gt;\r &lt;div class=\"p-3\"&gt;\r &#123;&#123;main}}\r &lt;\/div&gt;\r &lt;footer&gt;&copy; &#123;&#123;year}}&lt;\/footer&gt;\r &lt;\/body&gt;\r <\/script>\r <script type=\"text\/html\" id=\"view\">\r &lt;div class=\"bg-warning\"&gt;\r &#123;&#123;fromHome}}\r &lt;\/div&gt;\r <\/script>\r\n<\/section>","headlines":[{"id":"ssr","title":"About rendering","context":"It's important to understand how LENKRAD handles rendering in general. This page assumes that the default\r Renderer is used. Please refer to Response and Custom response handling\r for possibilities to influence rendering.\r \r \r \r The Rende"},{"id":"render","title":"The Render class","context":"The Renderer class has the following static methods:\r \r \r Method\r Description\r setTemplatePath(string $path)\r Sets the entry level of template-arguments\r getInstance(Renderer $mockInstance = null)\r Returns an existing insta"},{"id":"#skeleton-structure","title":"Skeleton structure","context":"\/src\/views\/skeleton.html\r This file contains the \"frame\"-html. Maybe header, menus, footer, etc.\r \r Respective component\/route HTML"},{"id":"class","title":"The Template class","context":"LENKRAD ships with neoan3-apps\/template as\r the default\r templating mechanism. Documentation for the package is provided, so here we only provide a very basic\r example to get\r you started.\r \r e.g. in \/src\/MyRoute\/MyRoute.php\r \r ...\r #[Web('\/my-route', '\/MyRou"}],"url":"\/docs\/templating"}]