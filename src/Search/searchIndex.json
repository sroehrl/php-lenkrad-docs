[{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/clibasics.html","topic":"{{name}}","description":"{{name}} introduction  The {{name}} class   The {{name}} class...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <h1>{{name}}<\/h1> <p>{{name}} introduction<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-primary\">The {{name}} class<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The {{name}} class<\/h2> <\/div>\n<\/section>","headlines":[{"id":"class","title":"The {{name}} class","context":""}],"url":"\/docs"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/clitool.html","topic":"{{name}}","description":"{{name}} introduction  The {{name}} class   The {{name}} class...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <h1>{{name}}<\/h1> <p>{{name}} introduction<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-contrast-light\">The {{name}} class<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The {{name}} class<\/h2> <\/div>\n<\/section>","headlines":[{"id":"class","title":"The {{name}} class","context":""}],"url":"\/docs"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/deploy.html","topic":"{{name}}","description":"{{name}} introduction  The {{name}} class   The {{name}} class...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <h1>{{name}}<\/h1> <p>{{name}} introduction<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-contrast-light\">The {{name}} class<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The {{name}} class<\/h2> <\/div>\n<\/section>","headlines":[{"id":"class","title":"The {{name}} class","context":""}],"url":"\/docs"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/dicontainer.html","topic":"{{name}}","description":"{{name}} introduction  The {{name}} class   The {{name}} class...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <h1>{{name}}<\/h1> <p>{{name}} introduction<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-contrast-light\">The {{name}} class<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The {{name}} class<\/h2> <\/div>\n<\/section>","headlines":[{"id":"class","title":"The {{name}} class","context":""}],"url":"\/docs"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/dynamicstore.html","topic":"{{name}}","description":"{{name}} introduction  The {{name}} class   The {{name}} class...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <h1>{{name}}<\/h1> <p>{{name}} introduction<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-contrast-light\">The {{name}} class<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The {{name}} class<\/h2> <\/div>\n<\/section>","headlines":[{"id":"class","title":"The {{name}} class","context":""}],"url":"\/docs"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/events.html","topic":"{{name}}","description":"{{name}} introduction  The {{name}} class   The {{name}} class...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <h1>{{name}}<\/h1> <p>{{name}} introduction<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-contrast-light\">The {{name}} class<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The {{name}} class<\/h2> <\/div>\n<\/section>","headlines":[{"id":"class","title":"The {{name}} class","context":""}],"url":"\/docs"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/home.html","topic":"getting started","description":"In order to get you set up, you can either create your own setup from scratch (see Quick Start) or use one of the starter projects.  Either way, in order to follow this documentation a working LENKRAD application is necessary.  Basics  LENKRAD is an all-purpose framework, but we are going to conce...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <h1>Getting Started<\/h1> <p> In order to get you set up, you can either create your own setup from scratch (see <a href=\"\/quick-start\">Quick Start<\/a>) or use one of the <a href=\"\/starter-projects\">starter projects<\/a>. <br> Either way, in order to follow this documentation a working LENKRAD application is necessary. <\/p> <h2>Basics<\/h2> <p> LENKRAD is an all-purpose framework, but we are going to concentrate on two of the most common use-cases in web development: <\/p> <ul> <li>API - a backend for your powerful frontend, app or embedded software<\/li> <li>SSR - A all-in-one monolith to generate anything from your personal site to your SAAS business<\/li> <\/ul> <h2>Cross-referencing<\/h2> <p> LENKRAD is very flexible, injectable and customizable and consists of loosely coupled components. This documentation is therefore prone to \"but in my case it's different\"-situations. Our starter projects are designed to mitigate this issue, but this does not change the fact that one page of this documentation will likely lead you to 3 others. The bad news is: there's a reason we call it a <em>core<\/em> instead of a framework. The good news is: the learning curve is not even half as bad as one might initially think. <\/p> <h2>Get in touch<\/h2> <p> This documentation is a living document inspired by your feedback & questions. If you want to engage, please visit <a href=\"https:\/\/github.com\/sroehrl\/php-lenkrad-docs\/issues\">Github<\/a> (While you are there, don't forget to star) <\/p> <h2>Terminology<\/h2> <p> Sometimes it's necessary to refer to concepts that aren't clear due to conflicting definitions. To avoid confusion as far as possible, we added a glossary: <\/p> <div class=\"grid grid-cols-3 gap-3\"> <div class=\"border-b-2 border-primary font-lg\">Term<\/div> <div class=\"border-b-2 border-primary font-lg\">Description<\/div> <div class=\"border-b-2 border-primary font-lg\">Notes<\/div> <h3 id=\"attributes\">Attributes<\/h3> <p> In PHP, attributes is the name given to what most other languages refer to as <em>annotation<\/em>. The feature was introduced in PHP8 LENKRAD makes heavy use of its capabilities. <\/p> <p> <\/p> <h3 id=\"web-route\">Web-route<\/h3> <p>Refers to a Route answering with markup (HTML) using a template.<\/p> <p>This very page is a web-route.<\/p> <h3 id=\"api-route\">API-route<\/h3> <p>Similarly, an API-route is intended to be machine read.<\/p> <p>LENKRAD's default response-handler defaults to JSON-format.<\/p> <h3 id=\"templating\">Templating<\/h3> <p>Templates are markup-shells (HTML) the rendering process uses to apply data to. <\/p> <p>Demo: click <a href=\"docs?say=HELLO\">here<\/a>, watch the url and then see this: {{say}}<\/p> <h3 id=\"middleware\">Middleware<\/h3> <p> In LENKRAD, this concept can be simplified down to code that is executed before your controller logic applies. Middleware can be chained to facilitate guards (e.g. authentication) or to ensure availability of certain data, permissions etc. <\/p> <p> Middleware normalization is very little opinionated in LENKRAD as execution chains are loosely coupled. <\/p> <h3 id=\"di\">Dependency Injection<\/h3> <p>The concept refers to injecting dependencies rather than coupling them. This is were Interfaces shine.<\/p> <p>LENKRAD has an auto-wire dependency injection. This allows you to inject concrete dependencies automatically as needed.<\/p> <\/div>\n<\/section>","headlines":[{"id":"attributes","title":"Attributes","context":"In PHP, attributes is the name given to what most other languages refer to as annotation. The feature was introduced in PHP8 LENKRAD makes heavy use of its capabilities.    Web-route Refers to a Route answering with markup (HTML) using a template. This very page is a web-route. API-route Similarly, an API-rou"},{"id":"web-route","title":"Web-route","context":"Refers to a Route answering with markup (HTML) using a template. This very page is a web-route. API-route Similarly, an API-route is intended to be machine read. LENKRAD's default response-handler defaults to JSON-format. Templating Templates are markup-shells (HTML) the rendering process uses to apply data to."},{"id":"api-route","title":"API-route","context":"Similarly, an API-route is intended to be machine read. LENKRAD's default response-handler defaults to JSON-format. Templating Templates are markup-shells (HTML) the rendering process uses to apply data to.  Demo: click here, watch the url and then see this: {{say}} Middleware  In LENKRAD"},{"id":"templating","title":"Templating","context":"Templates are markup-shells (HTML) the rendering process uses to apply data to.  Demo: click here, watch the url and then see this: {{say}} Middleware  In LENKRAD, this concept can be simplified down to code that is executed before your controller logic applies. Middleware can be chained to facilitate guards (e.g. authenticati"},{"id":"middleware","title":"Middleware","context":"In LENKRAD, this concept can be simplified down to code that is executed before your controller logic applies. Middleware can be chained to facilitate guards (e.g. authentication) or to ensure availability of certain data, permissions etc.   Middleware normalization is very little opinionated in LENKRAD as execution chains are loosely coupled.  Dependency Injection"},{"id":"di","title":"Dependency Injection","context":"The concept refers to injecting dependencies rather than coupling them. This is were Interfaces shine. LENKRAD has an auto-wire dependency injection. This allows you to inject concrete dependencies automatically as needed."}],"url":"\/docs"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/middleware.html","topic":"{{name}}","description":"{{name}} introduction  The {{name}} class   The {{name}} class...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <h1>{{name}}<\/h1> <p>{{name}} introduction<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-contrast-light\">The {{name}} class<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The {{name}} class<\/h2> <\/div>\n<\/section>","headlines":[{"id":"class","title":"The {{name}} class","context":""}],"url":"\/docs"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/models.html","topic":"models","description":"Models are the hear and soul of dealing with persistent data. LENKRAD has a sophisticated ORM automation to deal with this common topic. This means that when we talk about models, we always talk about databases as well.   The {{name}} class Defining a model Collections Using a model Pagination Mag...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\n<!--    url: \/docs\/models --> <h1>Models<\/h1> <p> Models are the hear and soul of dealing with persistent data. LENKRAD has a sophisticated ORM automation to deal with this common topic. This means that when we talk about models, we always talk about databases as well. <\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/models#class\" class=\"button-contrast-light\">The {{name}} class<\/a> <a href=\"\/docs\/models#define\" class=\"button-contrast-light\">Defining a model<\/a> <a href=\"\/docs\/models#collections\" class=\"button-contrast-light\">Collections<\/a> <a href=\"\/docs\/models#usage\" class=\"button-contrast-light\">Using a model<\/a> <a href=\"\/docs\/models#pagination\" class=\"button-contrast-light\">Pagination<\/a> <a href=\"\/docs\/models#magic\" class=\"button-contrast-light\">Magic methods<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The {{name}} class<\/h2> <p> LENKRAD uses one file to declare and interact with models. This includes: <\/p> <ul> <li>Database interactions<\/li> <li>Database migrations<\/li> <li>Object relational mapping<\/li> <\/ul> <p>A new instance of this model now has the following <em>static<\/em> methods available:<\/p> <div class=\"grid grid-cols-3 gap-3\"> <div class=\"border-b-2 border-primary font-lg span-x-2\">Method<\/div> <div class=\"border-b-2 border-primary font-lg\">Description<\/div> <p class=\"span-x-2\">get(int|string $id)<\/p> <p>Retrieves an instance of the model by primary id.<\/p> <p class=\"span-x-2\">retrieve(array $condition, array $filter = [])<\/p> <p>Returns a <a href=\"\/docs\/models#collections\">collection<\/a><\/p> <p class=\"span-x-2\">retrieveOne(array $condition, array $filter = [])<\/p> <p>Retrieves an instance of the model based on condition and\/or filter<\/p> <p class=\"span-x-2\">retrieveOneOrCreate(array $condition)<\/p> <p>If a model with the condition exists, it's retrieved, else it's created.<\/p> <p class=\"span-x-2\">paginate(int $page = 1, int $pageSize = 30)<\/p> <p>Returns a <a href=\"\/docs\/models#pagination\">Pagination<\/a> instance<\/p> <p class=\"span-x-2\">declare()<\/p> <p>Returns the structure in a standardized format (mainly to be used for migrations & transactions)<\/p> <\/div> <p>And the following <em>initiated<\/em> methods:<\/p> <div class=\"grid grid-cols-3 gap-3\"> <div class=\"border-b-2 border-primary font-lg span-x-2\">Method<\/div> <div class=\"border-b-2 border-primary font-lg\">Description<\/div> <p class=\"span-x-2\">store()<\/p> <p>Executes database transaction(s) to store model changes.<\/p> <p class=\"span-x-2\">delete(bool $hard = false)<\/p> <p>Soft or hard deletes the mapped entity.<\/p> <p class=\"span-x-2\">toArray()<\/p> <p>Converts the model object to an assoc array<\/p> <p class=\"span-x-2\">rehydrate()<\/p> <p>Refills (resets) the instance with database driven values<\/p> <p class=\"span-x-2\">getTransactionMode()<\/p> <p>Returns the TransactionType enum currently active (INSERT | UPDATE)<\/p> <p class=\"span-x-2\">setTransactionMode(TransactionType $type)<\/p> <p>Overrides the internal transaction mode.<\/p> <p class=\"span-x-2\">__call()<\/p> <p>See <a href=\"\/docs\/models#magic\">Magic methods<\/a><\/p> <\/div> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"define\">Defining a Model<\/h2> <p> In order to create a model new, you simply extend the <a href=\"\/docs\/models#class\">Model class<\/a> and give it the properties you need. <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App\\Models; use Neoan\\Model\\Model; use Neoan\\Model\\Attributes\\IsPrimaryKey; use Neoan\\Model\\Attributes\\IsUnique; use Neoan\\Model\\Attributes\\Transform; use Neoan\\Model\\Transformers\\Hash; class User extends Model { #[IsPrimaryKey] public int $id; #[IsUnique] public string $email; public string $userName; #[Transform(Hash::class)] public string $password; } <\/code><\/pre> <h3>Default & Custom Types<\/h3> <p> Depending on the database adapter you use (see <a href=\"\/quick-start\">Quick Start<\/a>), your PHP types will translate into a default column type. For example, the recommended MySQL adapter will assume a string to be <em>varchar<\/em> with the length of 255, a PHP integer to be <em>int<\/em> with a length of 11 and so on. If you want to influence this behavior, you can use attributes to do so. The generic attribute <em>Type<\/em> allows you to be very specific as well: <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> ... use Neoan\\Model\\Transformers\\Type; ... #[Type('LONGTEXT')] public $post; ... <\/code><\/pre> <p> The following model attributes are shipped with LENKRAD <\/p> <div class=\"grid grid-cols-2 gap-3\"> <div class=\"border-b-2 border-primary font-lg\">Attribute<\/div> <div class=\"border-b-2 border-primary font-lg\">Description<\/div> <p>HasMany(string $modelName, array $matchingRule = [])<\/p> <p>Enables automatic loading of one-to-many relationships by attaching a <a href=\"\/docs\/models#collections\">collection<\/a> <\/p> <p>Ignore<\/p> <p>Signifies a property that shall be ignored by database transactions.<\/p> <p>Initialize(mixed $setter)<\/p> <p>Attaches a value or instance to the model at creation. (For example a date-converter)<\/p> <p>IsForeignKey(string $table, string $property, string $modelName)<\/p> <p>Enhances relationship lookup performance and enables <a href=\"\/docs\/models#magic\">magic relationships<\/a> <\/p> <p>IsPrimaryKey<\/p> <p>REQUIRED! Indicates the index of a model for many operations.<\/p> <p>IsUnique<\/p> <p>handles UNIQUE constraints<\/p> <p>Transform(string $transformerClass)<\/p> <p> Generic hook for transforming values bi- or one-directional (own transformers must implement Neoan\\Model\\Interfaces\\Transformation). LENKRAD ships with the transformers <em>Hash<\/em> and <em>CurrentTimeIn<\/em> out of the box. <\/p> <p>Type(string $type, int $length = null, string $default = null)<\/p> <p>As discussed, enables custom column-type-matching<\/p> <\/div> <h3>Constants<\/h3> <p> To escape further default behavior, constants are used. With new Projects, there shouldn't be any necessity for that. <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> const tableName = 'user_table'; <\/code><\/pre> <div class=\"grid grid-cols-2 gap-3\"> <div class=\"border-b-2 border-primary font-lg\">Constant<\/div> <div class=\"border-b-2 border-primary font-lg\">Description<\/div> <p>tableName<\/p> <p>Overrides the usage of the class name as the table name.<\/p> <\/div> <h3>Traits<\/h3> <p> To simplify data structure, traits offer an easy way to escape duplication. LENKRAD offers the following model traits out of the box: <\/p> <div class=\"grid grid-cols-3 gap-3\"> <div class=\"border-b-2 border-primary font-lg\">Trait<\/div> <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div> <p>Setter<\/p> <p class=\"span-x-2\"> Enables the model to deal with private and\/or readonly properties. It also exposes the method <em>set(string $propertyName, mixed $value)<\/em> to the model. <\/p> <p>TimeStamps<\/p> <p class=\"span-x-2\"> Shorthand for the common fields <strong>createdAt, updatedAt, and deletedAt<\/strong>. In addition to allowing for soft-deletion, this trait handles time format transformations. <\/p> <\/div> <h3>Full Example<\/h3> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App\\Models; use Neoan\\Model\\Model; use Neoan\\Model\\Attributes\\IsPrimaryKey; use Neoan\\Model\\Attributes\\IsUnique; use Neoan\\Model\\Attributes\\Transform; use Neoan\\Model\\Transformers\\Hash; use Neoan\\Model\\Traits\\Setter; use Neoan\\Model\\Traits\\TimeStamps; class User extends Model { #[IsPrimaryKey] public readonly int $id; #[IsUnique] public string $email; public string $userName; #[Transform(Hash::class)] public string $password; use Setter; use TimeStamps; } <\/code><\/pre> <h3>Migration<\/h3> <p> Creating and updating tables according to your model must be done whenever changes to your model declaration have been conducted. The <a href=\"\/docs\/cli-basics\">cli tool<\/a> makes this possible using one command. <\/p> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"collections\">Collections<\/h2> <p> A collection instance is useful when dealing with multiple different instances of a given model. This is commonly the case when retrieving multiple entries. A collection is iterable and offers useful methods: <\/p> <div class=\"grid grid-cols-3 gap-3\"> <div class=\"border-b-2 border-primary font-lg\">Method<\/div> <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div> <p>each(fn)<\/p> <p class=\"span-x-2\"> Expects a closure or invokable while iterating over the instances. <\/p> <p>add(Model $instance)<\/p> <p class=\"span-x-2\"> Manually adds an instance to the collection. <\/p> <p>toArray<\/p> <p class=\"span-x-2\"> Returns all entries as one array. <\/p> <p>store<\/p> <p class=\"span-x-2\"> Runs store commands for all instances contained in the collection (beware of performance!). <\/p> <p>count<\/p> <p class=\"span-x-2\"> Returns an integer with the number of held model instances. <\/p> <\/div> <h3>Examples<\/h3> <pre class=\"normalize-code\"><code class=\"language-php\"> \/\/ this is an example, please don't take this seriously: \/\/ return all users as collection $userCollection = User::retrieve(); \/\/ a collection is iterable: foreach($userCollection as $userInstance){ ... } \/\/ but you likely want to make use of typing $userCollection->each(function(User $user){ if(str_ends_with($user->email, '@protonmail.com')) { $this->sendSecureEmail($user); } }); \/\/ how many users? $registeredUsers = $userCollection->count(); \/\/ add a new user if($registeredUsers &lt; $this->marketingGoal) { for($i = 0; $i &lt; $this->marketingGoal - $registeredUsers; $i++) { $bot = new User([ 'email' => \"myspam+{$i}@gmail.com\", 'userName' => 'bot-' . $i, 'password' => 'you-wish-800-' . $i ]); $userCollection->add($bot); } } \/\/ since we got ALL users, this could take a while... $userCollection->store(); <\/code><\/pre> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"usage\">Using a model<\/h2> <h3>Retrieval<\/h3> <h4 class=\"font-md\">Conditions<\/h4> <p> Let's begin by exploring how conditions work. Conditions are passed into a model as assoc arrays <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> $condition = [ 'email' => 'adam@email.com' ]; $user = User::retrieveOne($condition); <\/code><\/pre> <p> With the MySQL adapter, this roughly translates to <br> <code>SELECT * FROM user WHERE email = \"adam@email.com\"<\/code>. Roughly, as in reality queries are optimized and executed as prepared statements. The following examples should help you to read & write conditions: <\/p> <div class=\"grid grid-cols-3 gap-3\"> <div class=\"border-b-2 border-primary font-lg\">Array<\/div> <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div> <p>['email' => '%@email.com']<\/p> <p class=\"span-x-2\">Retrieve where email ends with \"@email\"<\/p> <p>['id' => '>100']<\/p> <p class=\"span-x-2\">Retrieve where id is greater than 100<\/p> <p>['userName' => '!adam']<\/p> <p class=\"span-x-2\">Retrieve where userName is not \"adam\"<\/p> <p>['updatedAt' => '!']<\/p> <p class=\"span-x-2\">Retrieve where updatedAt is not NULL (aka WHERE the record was updated at least once)<\/p> <p>['deletedAt' => null] or simply ['^deletedAt']<\/p> <p class=\"span-x-2\">Retrieve where deletedAt is NULL (aka undeleted entries)<\/p> <\/div> <p> Conditions are chained as <em>AND<\/em>, so <br> <code>['email' => '%@email.com', 'userName' => '!adam']<\/code> <br> retrieves records that meet both criteria. <\/p> <h4 class=\"font-md\">Filters<\/h4> <p> Both shipped adapters currently only provide two filters: <\/p> <div class=\"grid grid-cols-2 gap-3\"> <div class=\"border-b-2 border-primary font-lg\">Filter<\/div> <div class=\"border-b-2 border-primary font-lg\">Description<\/div> <p>orderBy => [string $property, string $ascOrDesc]<\/p> <p>Influences the sorting order of results<\/p> <p>limit => [int $offset, int $rowCount]<\/p> <p>Paginates results<\/p> <\/div> <pre class=\"normalize-code\"><code class=\"language-php\"> $filter = [ 'orderBy' => ['userName', 'desc'], 'limit' => [0,10] ]; $user = User::retrieve([], $filter); <\/code><\/pre> <p> This would return 10 entries sorted by userName in reverse alphabetical order. <\/p> <blockquote> Note: If you are worried about limited complexity, rest assured that direct usage of the Database class can handle any potential bottleneck. <\/blockquote> <h4 class=\"font-md\">Security<\/h4> <p> Conditions are matched against the structure and type of a given model and transactions are executed as prepared statements. This annihilates user-input concerns. <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> \/\/ yes, this is save to do $postedInput = Request::getInputs(); $user = User::retrieveOne($postedInput); <\/code><\/pre> <h3>Create<\/h3> <p> Creating a new model entry is as straight forward as it can be: <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> \/\/ as empty instance $user = new User(); \/\/ write $user->userName = 'Adam'; \/\/ if type is correct, will set \/\/ or directly with values passed as array $user = new User(['userName' => 'Adam']); \/\/ read echo $user->userName; \/\/ \"Adam\" \/\/ write $user->userName = 'Ben'; \/\/ overrides old value try{ $user->store(); } catch(\\Exception $e) { \/\/ ups... some properties are neither nullable nor have a default value \/\/ so we have to set email & password } $user->password = '123123'; $user->email = 'ben@email.com'; \/\/ if a setter is used you can also do: $user->set('password', '123123') ->set('email', 'ben@email.com'); $user->store(); \/\/ after database transaction, we have an id (or other primary key)! $userId = $user->id; <\/code><\/pre> <h3>Update<\/h3> <p> Updating an entry is no different from creation. <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> $user = User::retrieveOne(['email' => 'ben@email.com']); \/\/ rename $user->userName = 'Benjamin'; \/\/ save changes to db $user->store(); <\/code><\/pre> <h3>Collection properties<\/h3> <p> If you looked at the attribute-section of <a href=\"\/docs\/models#class\">the model class<\/a>, you might have noticed the <em>HasMany<\/em>-attribute. In a real world scenario, one might have two models: <\/p> <p>Movie model<\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App\\Models; use Neoan\\Model\\Model; use Neoan\\Model\\Collection; use Neoan\\Model\\Attributes\\IsPrimaryKey; use Neoan\\Model\\Attributes\\HasMany; use Neoan\\Model\\Traits\\TimeStamps; class Movie extends Model { #[IsPrimaryKey] public int $id; public string $name; #[HasMany(Rating::class)] public Collection $ratings; use TimeStamps; } <\/code><\/pre> <p>Rating model<\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App\\Models; use Neoan\\Model\\Model; use Neoan\\Model\\Collection; use Neoan\\Model\\Attributes\\IsPrimaryKey; use Neoan\\Model\\Attributes\\IsForeignKey; use Neoan\\Model\\Traits\\TimeStamps; class Rating extends Model { #[IsPrimaryKey] public int $id; #[IsForeignKey('movie', 'id')] public int $movieId; public int $rating; use TimeStamps; } <\/code><\/pre> <p> The result when retrieving movies now has ratings automatically attached. <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> $movie = Movie::get(1); \/\/ the property ratings is already a filled collection $numberOfRatings = $movie->ratings->count(); <\/code><\/pre> <p> Be aware that automatically attaching large numbers of rows can lead to performance issues. Since a model is just a class, you can always optimize by providing own methods: <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> ... class Movie extends Model { ... public ratings(): Collection { return Rating::retrieve(['movieId' => $this->id]); } } <\/code><\/pre> <p>And then use them accordingly:<\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> $movie = Movie::get(1); \/\/ the property ratings is already a filled collection $numberOfRatings = $movie->ratings()->count(); <\/code><\/pre> <p>Have a look at <a href=\"\/docs\/models#magic\">Magic methods<\/a> for how one-to-one relationships are automated for this.<\/p> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"pagination\">Pagination<\/h2> <p> Pagination is a common task when dealing with lists and\/or large numbers of expected results. LENKRAD simplified this process. <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> $page = 1; $resultsPerPage = 25; return User::paginate($page, $resultsPerPage) \/\/ you can use the regular condition array to specify ->where(['^deletedAt]) \/\/ newest users first? Let's get the last ids first ->descending('id') \/\/ when you're done specifying, execute ->get(); <\/code><\/pre> <p> The response of a pagination call is standardized and returns the structure: <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> [ 'page' => 1,    \/\/ current page 'total' => 48,      \/\/ total hits 'pageSize' => 25,       \/\/ number of results per page 'pages' => 2,       \/\/ total number of resulting pages 'collection' => `{Collection}`      \/\/ result as Collection ] <\/code><\/pre> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"magic\">Magic methods<\/h2> <p> LENKRAD avoids magic methods as we believe in empowering your IDE to do its job without having to write comments like it's 2015. However, models DO have a __call-implementation and attributes can make use of it. Out of the box, the attribute <em>IsForeignKey<\/em> uses it. Let's revive our movie class and add the property \"director\" to see it in action: <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App\\Models; use Neoan\\Model\\Model; use Neoan\\Model\\Collection; use Neoan\\Model\\Attributes\\IsPrimaryKey; use Neoan\\Model\\Attributes\\IsForeignKey; use Neoan\\Model\\Attributes\\HasMany; use Neoan\\Model\\Traits\\TimeStamps; class Movie extends Model { #[IsPrimaryKey] public int $id; public string $name; #[HasMany(Rating::class)] public Collection $ratings; \/\/ let's pretend we have a model \"Director\" #[IsForeignKey('director','id', Director::class)] public int $directorId; use TimeStamps; \/\/ Bonus: let's add a static helper after noticing we tend to \/\/ always get movies by name, but for some reason programmatically \/\/ (In reality one would likely notice that this is rarely necessary) public static function byName( string $name): ?self { return self::retrieveOne(['name' => $name]); } } <\/code><\/pre> <p> In action: <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> $movie = Movie::byName('Avatar'); \/\/ Of course we have the directorId available $directorId = $movie->directorId; \/\/ now let's get the associated director! if($directorId === $movie->director()->id){ \/\/ as you have guessed, we now have the director available } <\/code><\/pre> <blockquote> As mentioned, your IDE will not suggest the availability of magic methods. Refer to your IDE's guide on how to add magic methods to your suggestions (usually @method) <\/blockquote> <\/div>\n<\/section>","headlines":[{"id":"class","title":"The {{name}} class","context":"LENKRAD uses one file to declare and interact with models. This includes:   Database interactions Database migrations Object relational mapping  A new instance of this model now has the following static methods available:  Method"},{"id":"define","title":"Defining a Model","context":"In order to create a model new, you simply extend the Model class and give it the properties you need.   namespace App\\Models; use Neoan\\Model\\Model; use Neoan\\Model\\Attributes\\IsPrimaryKey; use Neoan\\Model\\Attributes\\IsUnique; use Neoan\\Model\\Attributes\\Transform; use Neoan\\Model\\Transformers\\Hash; cl"},{"id":"collections","title":"Collections","context":"A collection instance is useful when dealing with multiple different instances of a given model. This is commonly the case when retrieving multiple entries. A collection is iterable and offers useful methods:   Method Description each(fn"},{"id":"usage","title":"Using a model","context":"Retrieval Conditions  Let's begin by exploring how conditions work. Conditions are passed into a model as assoc arrays   $condition = [ 'email' => 'adam@email.com' ]; $user = User::retrieveOne($condition);   With the MySQL adapter, this roughly translates to  SELECT * FROM use"},{"id":"pagination","title":"Pagination","context":"Pagination is a common task when dealing with lists and\/or large numbers of expected results. LENKRAD simplified this process.   $page = 1; $resultsPerPage = 25; return User::paginate($page, $resultsPerPage) \/\/ you can use the regular condition array to specify ->where(['^deletedAt]) \/\/ newest users first? Let's get the last ids first"},{"id":"magic","title":"Magic methods","context":"LENKRAD avoids magic methods as we believe in empowering your IDE to do its job without having to write comments like it's 2015. However, models DO have a __call-implementation and attributes can make use of it. Out of the box, the attribute IsForeignKey uses it. Let's revive our movie class and add the property \"director\" to see it in action:"}],"url":"\/docs\/models"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/request.html","topic":"request","description":"{{name}} introduction  The {{name}} class   The {{name}} class...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\n<!--    url: \/docs\/request --> <h1>Request<\/h1> <p>{{name}} introduction<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-contrast-light\">The {{name}} class<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The {{name}} class<\/h2> <\/div>\n<\/section>","headlines":[{"id":"class","title":"The {{name}} class","context":""}],"url":"\/docs\/request"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/response.html","topic":"response","description":"{{name}} introduction  The {{name}} class Setting defaults   The {{name}} class   Setting defaults...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\n<!--    url \/docs\/response --> <h1>Response<\/h1> <p>{{name}} introduction<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-contrast-light\">The {{name}} class<\/a> <a href=\"\/docs\/{{name.lower}}#response-defaults\" class=\"button-contrast-light\">Setting defaults<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The {{name}} class<\/h2> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"response-defaults\">Setting defaults<\/h2> <\/div>\n<\/section>","headlines":[{"id":"class","title":"The {{name}} class","context":"Setting defaults"},{"id":"response-defaults","title":"Setting defaults","context":""}],"url":"\/docs"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/routing.html","topic":"routing","description":"Routing of endpoints can be handled by attribute or declaration. This page will explain both.  The Route class Middleware Chaining Route Parameters Direct Injections Custom Response Handling Attribute Routing   The Route class  Like most core-classes, Route is used statically while maintaining a si...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\">\n<!--  url: \/docs\/routing  --> <h1>Routing<\/h1> <p>Routing of endpoints can be handled by attribute or declaration. This page will explain both.<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/routing#class\" class=\"button-contrast-light\">The Route class<\/a> <a href=\"\/docs\/routing#chaining\" class=\"button-contrast-light\">Middleware Chaining<\/a> <a href=\"\/docs\/routing#parameter\" class=\"button-contrast-light\">Route Parameters<\/a> <a href=\"\/docs\/routing#inject\" class=\"button-contrast-light\">Direct Injections<\/a> <a href=\"\/docs\/routing#response\" class=\"button-contrast-light\">Custom Response Handling<\/a> <a href=\"\/docs\/routing#attribute\" class=\"button-contrast-light\">Attribute Routing<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The Route class<\/h2> <p> Like most core-classes, <em>Route<\/em> is used statically while maintaining a single instance of itself. It's responsible for registering routes. <\/p> <h3>Main methods<\/h3> <div class=\"grid grid-cols-3 gap-3 w-full overflow-x-auto overflow-x-auto\"> <div class=\"border-b-2 border-primary font-lg\">Method<\/div> <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div> <p>Route::get<\/p> <p class=\"span-x-2\">Registers a GET request<\/p> <p>Route::post<\/p> <p class=\"span-x-2\">Registers a POST request<\/p> <p>Route::put<\/p> <p class=\"span-x-2\">Registers a PUT request<\/p> <p>Route::patch<\/p> <p class=\"span-x-2\">Registers a PATCH request<\/p> <p>Route::delete<\/p> <p class=\"span-x-2\">Registers a DELETE request<\/p> <p>Route::request<\/p> <p class=\"span-x-2\">Registers other\/custom requests<\/p> <\/div> <p> With the exception of <em>Route::request<\/em>, these methods all take the same arguments. LENKRAD intends to work with your IDE and tries to reduce string usage by the user. For these methods, this means that classnames are provided to a route. A class must fulfill the following requirements:  <\/p> <ul> <li>Implements Neoan\\Routing\\Interfaces\\Routable<\/li> <li>Has __invoke method<\/li> <li>Returns a serializable result, a <a href=\"\/docs\/models\">Model, a Collection<\/a> or a DataNormalization instance<\/li> <\/ul> <h3>Example or a routable class<\/h3> <pre class=\"normalize-code\"><code class=\"language-php\"> ?php namespace App; use Neoan\\Routing\\Interfaces\\Routable; class Controller implements Routable { public function __invoke(): array { return ['test' => 'message']; } } <\/code><\/pre> <h3>Example of a route using <em>Controller.php<\/em><\/h3> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App; use Neoan\\Routing\\Route; Route::get('\/test', Controller::class); <\/code><\/pre> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"chaining\">Middleware Chaining<\/h2> <p>A route definition can chain routable classes as needed:<\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App; use Neoan\\Routing\\Route; Route::get('\/test', Auth::class, ReadUserFile::class, Controller::class); <\/code><\/pre> <p>This will execute one class after another. For a better understanding on how to utilize this feature, please refer to the <a href=\"\/docs\/middleware\">Middleware chapter<\/a> of this documentation<\/p> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"parameter\">Route parameter<\/h2> <p> In both API & SSR routes, variable parameters are a common necessity. Like many other frameworks in various languages, LENKRAD solves this by markup: <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App; use Neoan\\Routing\\Route; \/\/ Route will respond to \/test\/{anything} Route::get('\/test\/:name', Controller::class); \/\/ Route will respond to \/test and \/test\/{anything} Route::get('\/test\/:name*', Controller::class); \/\/ Multiple parameters are possible Route::get('\/test\/:name\/:id*', Controller::class); <\/code><\/pre> <h3>Variable usage<\/h3> <p> Routes using parameters provide their content to <a href=\"\/docs\/request\">Request<\/a>. To indicate a part of the route as parameter, prefix it with <em>: (colon)<\/em>. To indicate a part of the route is an optional parameter, additionally append it with <em>* (asterisks)<\/em> <\/p> <blockquote> Careful when chaining parameters. It's a common trap to pollute namespaces. <\/blockquote> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"inject\">Direct Injection<\/h2> <p> In very simple projects or routes, the necessity for logic might be overkill. You can therefore directly pass values to the response instead of using a class. <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App; use Neoan\\Routing\\Route; use Neoan\\Request\\Request; Route::get('\/test\/:name') ->inject(Request::getParameters()); <\/code><\/pre> <blockquote> Note that without additional changes to defaults, this only works for the standard JSON response. <\/blockquote> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"response\">Custom response handling<\/h2> <p> We speak of an either\/or when talking about responses. However, in reality you might have different response requirements for a particular route. This is why it's possible to overwrite the default behavior per route. <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> namespace App; use Neoan\\Routing\\Route; use Neoan\\Response\\Response; \/\/ using the default response handler, but overwriting its current default handling Route::get('\/test', Controller::class) ->view('templates\/test.html') ->response([Response::class,'html']); \/\/ using your own response handler and its method \"answer\" Route::get('\/test', Controller::class) ->response([MyResponseHandler::class,'answer']); <\/code><\/pre> Response handling is further explained in <a href=\"\/docs\/response\">Response<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"attribute\">Attribute Routing<\/h2> <p> Ever since Ruby on Rails exploded onto the world, annotational routing took the developer's interest. In LENKRAD, you can achieve this with attributes on the class-level. <\/p> <h3>Setup<\/h3> <p> In order to make use of this convenient way of defining routes, add the following lines to your index.php in your public folder: <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> ... $app = new NeoanApp( $appPath, $publicPath, $cliPath); \/\/ enable attribute routing $namespaceToExploreRecursively = 'App'; $app->invoke(new Neoan\\Routing\\AttributeRouting($namespaceToExploreRecursively)); $app->run(); <\/code><\/pre> <h3>Examples<\/h3> <div class=\"grid grid-cols-6 gap-3 w-full overflow-x-auto\"> <div class=\"border-b-2 border-primary font-lg\">Attribute<\/div> <div class=\"border-b-2 border-primary font-lg span-x-2\">Description<\/div> <div class=\"border-b-2 border-primary font-lg span-x-3\">Example<\/div> <p>Web<\/p> <p class=\"span-x-2\">Resolves html routes<\/p> <p class=\"span-x-3\">#[Web('\/test', 'test.html')]<\/p> <p>Get<\/p> <p class=\"span-x-2\">Resolves API-GET routes<\/p> <p class=\"span-x-3\">#[Get('\/api\/test')]<\/p> <p>Post<\/p> <p class=\"span-x-2\">Resolves API-GET routes<\/p> <p class=\"span-x-3\">#[Post('\/api\/test', AuthGuard::class)]<\/p> <p>Put<\/p> <p class=\"span-x-2\">Resolves API-PUT routes<\/p> <p class=\"span-x-3\">#[Put('\/api\/test', AuthGuard::class)]<\/p> <\/div> <p> Generally, the behavior is identical to declaring routes manually. <\/p> <pre class=\"normalize-code\"><code class=\"language-php\"> ?php namespace App; \/\/ Don't forget the use-statement! use Neoan\\Routing\\Attributes\\Get; use Neoan\\Routing\\Interfaces\\Routable; #[Get('\/api\/test')] class Controller implements Routable { public function __invoke(): array { return ['test' => 'message']; } } <\/code><\/pre> <\/div> <\/section>","headlines":[{"id":"class","title":"The Route class","context":"Like most core-classes, Route is used statically while maintaining a single instance of itself. It's responsible for registering routes.  Main methods  Method Description Route::ge"},{"id":"chaining","title":"Middleware Chaining","context":"A route definition can chain routable classes as needed:  namespace App; use Neoan\\Routing\\Route; Route::get('\/test', Auth::class, ReadUserFile::class, Controller::class);  This will execute one class after another. For a better understanding on how to utilize this feature, please refer to the"},{"id":"parameter","title":"Route parameter","context":"In both API & SSR routes, variable parameters are a common necessity. Like many other frameworks in various languages, LENKRAD solves this by markup:   namespace App; use Neoan\\Routing\\Route; \/\/ Route will respond to \/test\/{anything} Route::get('\/test\/:name', Controller::class); \/\/ Route will respond to \/test and \/test\/{anything} Rout"},{"id":"inject","title":"Direct Injection","context":"In very simple projects or routes, the necessity for logic might be overkill. You can therefore directly pass values to the response instead of using a class.   namespace App; use Neoan\\Routing\\Route; use Neoan\\Request\\Request; Route::get('\/test\/:name') ->inject(Request::getParameters());   Note that without a"},{"id":"response","title":"Custom response handling","context":"We speak of an either\/or when talking about responses. However, in reality you might have different response requirements for a particular route. This is why it's possible to overwrite the default behavior per route.   namespace App; use Neoan\\Routing\\Route; use Neoan\\Response\\Response; \/\/ using the default response handler, but overw"},{"id":"attribute","title":"Attribute Routing","context":"Ever since Ruby on Rails exploded onto the world, annotational routing took the developer's interest. In LENKRAD, you can achieve this with attributes on the class-level.  Setup  In order to make use of this convenient way of defining routes, add the following lines to your index.php in your public folder:   ... $app ="}],"url":"\/docs\/routing"},{"file":"C:\\xampp\\htdocs\\neoan.io-tools\\php-lenkrad-docs\/src\/views\/docs\/templating.html","topic":"{{name}}","description":"{{name}} introduction  About rendering The Render class The {{name}} class   About rendering  It's important to understand how LENKRAD handles rendering in general. This page assumes that the default Renderer is used. Please refer to Response and Custom response handling for possibilities to influe...","content":"<section class=\"w-4\/5 xl:w-3\/5 xxl:w-3\/5 m-x-auto mt-5\"> <h1>{{name}}<\/h1> <p>{{name}} introduction<\/p> <div class=\"flex flex-wrap gap-4 \" style=\"justify-content: space-between\"> <a href=\"\/docs\/{{name.lower}}#ssr\" class=\"button-contrast-light\">About rendering<\/a> <a href=\"\/docs\/{{name.lower}}#render\" class=\"button-contrast-light\">The Render class<\/a> <a href=\"\/docs\/{{name.lower}}#class\" class=\"button-contrast-light\">The {{name}} class<\/a> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"ssr\">About rendering<\/h2> <p> It's important to understand how LENKRAD handles rendering in general. This page assumes that the default Renderer is used. Please refer to <a href=\"\/docs\/response\">Response<\/a> and <a href=\"\/docs\/routing#response\">Custom response handling<\/a> for possibilities to influence rendering. <\/p> <\/div> <div class=\"bg-neutral border-r-1 border-secondary p-3 mt-10\"> <h2 id=\"class\">The {{name}} class<\/h2> <p> LENKRAD ships with <a href=\"https:\/\/packagist.org\/packages\/neoan3-apps\/template\">neoan3-apps\/template<\/a> as the default templating mechanism. Documentation for the package is provided, so here we only provide a very basic example to get you <\/p> <p> <\/p> <\/div>\n<\/section>","headlines":[{"id":"ssr","title":"About rendering","context":"It's important to understand how LENKRAD handles rendering in general. This page assumes that the default Renderer is used. Please refer to Response and Custom response handling for possibilities to influence rendering.    The {{name}} class"},{"id":"class","title":"The {{name}} class","context":"LENKRAD ships with neoan3-apps\/template as the default templating mechanism. Documentation for the package is provided, so here we only provide a very basic example to get you"}],"url":"\/docs"}]